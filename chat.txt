import os
import cv2
import torch
import numpy as np
import argparse
import pathlib

from utils import util
import options.options as option
from models import create_model

import torchvision.transforms as transforms


def main():
    # 配置参数解析
    parser = argparse.ArgumentParser()
    parser.add_argument('--opt', type=str, default='./options/test.yml', help='Path to option YAML file.')
    parser.add_argument('--input_dir', type=str, required=True, help='Input directory containing images')
    parser.add_argument('--output_dir', type=str, required=True, help='Output directory for processed images')
    args = parser.parse_args()

    # 加载配置文件
    opt = option.parse(args.opt, is_train=False)
    opt['dist'] = False

    # 创建输出目录
    os.makedirs(args.output_dir, exist_ok=True)

    # 初始化模型
    model = create_model(opt)
    # 加载预训练权重
    para = {}
    for k, v in torch.load(opt['path']['pretrain_model_G']).items():
        para['module.'+k] = v  # 添加module前缀匹配模型参数名称
    model.netG.load_state_dict(para, strict=True)
    model.netG.eval()

    # 支持的图片格式
    supported_ext = ['.png', '.jpg', '.jpeg', '.bmp', '.tif', '.tiff']
    
    # 遍历输入目录
    input_path = pathlib.Path(args.input_dir)
    for img_path in input_path.iterdir():
        if img_path.suffix.lower() not in supported_ext:
            continue

        # 读取图片
        image = cv2.imread(str(img_path))
        if image is None:
            print(f"Error reading image: {img_path}")
            continue

        # 预处理
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        transform = transforms.ToTensor()
        tensor_image = transform(image).unsqueeze(0)

        # 模型推理
        with torch.no_grad():
            output = util.single_forward(model.netG, tensor_image)

        # 后处理
        np_image = util.tensor2img(output)
        np_image = cv2.cvtColor(np_image, cv2.COLOR_RGB2BGR)

        # 保存结果
        output_path = pathlib.Path(args.output_dir) / img_path.name
        cv2.imwrite(str(output_path), np_image)
        print(f"Processed image saved to: {output_path}")


if __name__ == "__main__":
    main()
