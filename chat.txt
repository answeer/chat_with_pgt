import os
import cv2
import json
import numpy as np
from paddleocr import PaddleOCR
from editdistance import eval as edit_distance

class PaddleOCREvaluator:
    def __init__(self, model_type='PP-OCRv4'):
        # 初始化PaddleOCR模型（端到端模式：检测+识别）
        self.ocr = PaddleOCR(
            use_angle_cls=True,  # 启用方向分类
            lang='en',            # 支持中英文（修改为 'ch' 中文）
            det_model_dir=None,   # 自动下载预训练模型
            rec_model_dir=None,
            cls_model_dir=None,
            use_gpu=False,        # 根据环境选择
            show_log=False
        )
        self.model_type = model_type

    def load_annotations(self, annotation_path):
        """加载标注数据（示例：FUNSD格式的JSON标注）"""
        with open(annotation_path, 'r') as f:
            data = json.load(f)
        annotations = {}
        for item in data['form']:
            img_name = item['image_path'].split('/')[-1]
            if img_name not in annotations:
                annotations[img_name] = []
            annotations[img_name].append({
                'points': np.array(item['box'], dtype=np.int32).reshape(4, 2),  # 四边形坐标
                'text': item['text']
            })
        return annotations

    def calculate_iou(self, box1, box2):
        """计算两个四边形的最小外接矩形IoU"""
        rect1 = cv2.boundingRect(box1)
        rect2 = cv2.boundingRect(box2)
        x1, y1, w1, h1 = rect1
        x2, y2, w2, h2 = rect2
        
        # 计算交集区域
        x_left = max(x1, x2)
        y_top = max(y1, y2)
        x_right = min(x1 + w1, x2 + w2)
        y_bottom = min(y1 + h1, y2 + h2)
        
        if x_right < x_left or y_bottom < y_top:
            return 0.0
        
        intersection_area = (x_right - x_left) * (y_bottom - y_top)
        union_area = w1 * h1 + w2 * h2 - intersection_area
        return intersection_area / union_area if union_area != 0 else 0.0

    def evaluate(self, image_dir, annotation_path, iou_threshold=0.5):
        """端到端评估：检测+识别"""
        annotations = self.load_annotations(annotation_path)
        total_tp, total_fp, total_fn = 0, 0, 0
        total_char_acc = 0.0
        total_word_acc = 0.0
        total_samples = 0

        for img_name, gt_boxes in annotations.items():
            img_path = os.path.join(image_dir, img_name)
            if not os.path.exists(img_path):
                print(f"Warning: {img_path} not found. Skipping...")
                continue

            # PaddleOCR推理
            result = self.ocr.ocr(img_path, cls=True)
            pred_boxes = []
            if result is not None:
                for line in result:
                    if line is not None:
                        points = np.array(line[0], dtype=np.int32).reshape(4, 2)
                        text = line[1][0]
                        confidence = line[1][1]
                        pred_boxes.append({'points': points, 'text': text})

            # 匹配预测与标注
            matched_gt = set()
            matched_pred = set()
            
            # 检测指标计算
            for pred_idx, pred in enumerate(pred_boxes):
                max_iou = 0.0
                best_gt_idx = -1
                for gt_idx, gt in enumerate(gt_boxes):
                    if gt_idx in matched_gt:
                        continue
                    iou = self.calculate_iou(pred['points'], gt['points'])
                    if iou > max_iou and iou >= iou_threshold:
                        max_iou = iou
                        best_gt_idx = gt_idx
                if best_gt_idx != -1:
                    matched_gt.add(best_gt_idx)
                    matched_pred.add(pred_idx)
                    # 识别指标计算
                    gt_text = gt_boxes[best_gt_idx]['text'].lower().strip()
                    pred_text = pred['text'].lower().strip()
                    # 字符级准确率
                    char_acc = 1 - edit_distance(gt_text, pred_text) / max(len(gt_text), len(pred_text))
                    total_char_acc += char_acc
                    # 单词级准确率
                    if gt_text == pred_text:
                        total_word_acc += 1

            # 统计TP/FP/FN
            tp = len(matched_gt)
            fp = len(pred_boxes) - tp
            fn = len(gt_boxes) - tp
            total_tp += tp
            total_fp += fp
            total_fn += fn
            total_samples += len(gt_boxes)

        # 计算最终指标
        precision = total_tp / (total_tp + total_fp + 1e-9)
        recall = total_tp / (total_tp + total_fn + 1e-9)
        f1 = 2 * (precision * recall) / (precision + recall + 1e-9)
        avg_char_acc = total_char_acc / total_samples if total_samples > 0 else 0
        avg_word_acc = total_word_acc / total_samples if total_samples > 0 else 0

        return {
            "precision": round(precision, 4),
            "recall": round(recall, 4),
            "f1": round(f1, 4),
            "char_accuracy": round(avg_char_acc, 4),
            "word_accuracy": round(avg_word_acc, 4),
            "total_samples": total_samples
        }

if __name__ == "__main__":
    # 示例用法（假设数据按FUNSD格式组织）
    evaluator = PaddleOCREvaluator(model_type='PP-OCRv4')
    results = evaluator.evaluate(
        image_dir="path/to/test_images",       # 测试图片目录
        annotation_path="path/to/annotations.json"  # 标注文件（FUNSD格式）
    )
    
    print("\n===== 评估结果 =====")
    print(f"检测精确率 (Precision): {results['precision']}")
    print(f"检测召回率 (Recall): {results['recall']}")
    print(f"检测F1分数: {results['f1']}")
    print(f"字符级准确率: {results['char_accuracy']}")
    print(f"单词级准确率: {results['word_accuracy']}")
    print(f"总样本数: {results['total_samples']}")
