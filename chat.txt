from neo4j import GraphDatabase, basic_auth
from neo4j.exceptions import Neo4jError
import time
from typing import List, Dict

class Neo4jDataLoader:
    def __init__(self, uri: str, user: str, password: str, batch_size: int = 1000):
        self.driver = GraphDatabase.driver(uri, auth=basic_auth(user, password))
        self.batch_size = batch_size
        
    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.driver.close()

    def load_data(self, file_path: str):
        """主数据加载方法"""
        with open(file_path, 'r') as f:
            batch = []
            for line in f:
                parsed = self._parse_line(line.strip())
                if parsed and not self._is_self_loop(parsed):
                    batch.append(parsed)
                    
                if len(batch) >= self.batch_size:
                    self._process_batch(batch)
                    batch = []
            
            if batch:  # 处理剩余数据
                self._process_batch(batch)

    def _parse_line(self, line: str) -> Dict:
        """解析数据行（根据实际数据格式修改）"""
        try:
            # 示例数据格式: FromLabel|FromID|FromName|RelType|ToLabel|ToID|ToName
            parts = line.split('|')
            return {
                "from_label": parts[0],
                "from_id": parts[1],
                "from_name": parts[2],
                "rel_type": parts[3],
                "to_label": parts[4],
                "to_id": parts[5],
                "to_name": parts[6]
            }
        except Exception as e:
            print(f"数据解析失败: {line} - {str(e)}")
            return None

    def _is_self_loop(self, data: Dict) -> bool:
        """自环检测逻辑"""
        return (
            data["from_id"] == data["to_id"] and 
            data["from_label"] == data["to_label"]
        )

    def _process_batch(self, batch: List[Dict], max_retries: int = 3):
        """处理批次数据（带重试机制）"""
        for attempt in range(max_retries):
            try:
                with self.driver.session() as session:
                    session.execute_write(self._create_relationships, batch)
                print(f"成功导入批次: {len(batch)} 条关系")
                return
            except Neo4jError as e:
                print(f"批次导入失败（尝试 {attempt+1}/{max_retries}）: {str(e)}")
                time.sleep(2 ​** attempt)  # 指数退避
        print(f"无法导入批次，已跳过 {len(batch)} 条数据")

    @staticmethod
    def _create_relationships(tx, batch: List[Dict]):
        """Cypher 事务函数"""
        query = """
        UNWIND $batch AS row
        MERGE (a:`%s` {id: $from_id}) 
        ON CREATE SET a.name = $from_name
        MERGE (b:`%s` {id: $to_id})
        ON CREATE SET b.name = $to_name
        MERGE (a)-[r:`%s`]->(b)
        """
        
        for item in batch:
            formatted_query = query % (
                item["from_label"],
                item["to_label"],
                item["rel_type"]
            )
            tx.run(
                formatted_query,
                from_id=item["from_id"],
                from_name=item["from_name"],
                to_id=item["to_id"],
                to_name=item["to_name"]
            )

if __name__ == "__main__":
    # 使用示例
    with Neo4jDataLoader(
        uri="bolt://localhost:7687",
        user="neo4j",
        password="your_password",
        batch_size=1000
    ) as loader:
        loader.load_data("data.txt")
