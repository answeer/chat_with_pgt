# æ–°å¢æ•°æ®ç»“æ„
from dataclasses import dataclass
from typing import Dict, List

@dataclass
class DataPolicyConfig:
    data_paths: List[str]       # æ•°æ®è·¯å¾„åˆ—è¡¨ ["params.service_path"]
    data_type: str              # æ•°æ®ç±»å‹ "text"
    policies: List[str]         # å…³è”ç­–ç•¥ ["001_free_text_bounding_policy"]
    scanners: Dict[str, List]  # åˆ†ç±»åçš„æ‰«æå™¨ {"bounding": ["TokenLimit", ...]}
    api_calls: List[Dict]       # éœ€è¦è°ƒç”¨çš„APIåˆ—è¡¨

# å¢å¼ºçš„manifestå¤„ç†é€»è¾‘
def process_manifest(manifest_content: str) -> List[DataPolicyConfig]:
    """ç”Ÿæˆæ¯ä¸ªdataé…ç½®é¡¹çš„å¤„ç†æ–¹æ¡ˆ"""
    configs = []
    manifest_data = parse_manifest(manifest_content)
    
    for agent_name, agent_config in manifest_data.items():
        input_data = agent_config.get('guardrails', {}).get('input_data', {})
        
        for data_type, type_configs in input_data.items():
            for config in type_configs:
                # åˆ›å»ºé…ç½®å®ä¾‹
                policy_config = DataPolicyConfig(
                    data_paths=config.get('data', []),
                    data_type=data_type,
                    policies=config.get('policies', []),
                    scanners={},
                    api_calls=[]
                )
                
                # å¤„ç†ç­–ç•¥æ˜ å°„
                scanners = process_policies(policy_config.policies)
                policy_config.scanners = scanners
                
                # ç”ŸæˆAPIè°ƒç”¨è®¡åˆ’
                for category in ['bounding', 'sanitation', 'validator']:
                    if scanners.get(category):
                        policy_config.api_calls.append({
                            "api": API_MAPPING[category],
                            "scanners": scanners[category],
                            "data_type": data_type
                        })
                
                configs.append(policy_config)
    
    return configs

# å¢å¼ºçš„UIå±•ç¤º
def display_policy_configs(configs: List[DataPolicyConfig]):
    """å¯è§†åŒ–å±•ç¤ºæ¯ä¸ªdataé…ç½®é¡¹çš„å¤„ç†æµç¨‹"""
    for idx, config in enumerate(configs, 1):
        with st.expander(f"Dataé…ç½®é¡¹ #{idx} [{config.data_type}]", expanded=True):
            # åŸºæœ¬ä¿¡æ¯åˆ—
            col_meta, col_detail = st.columns([1, 3])
            
            with col_meta:
                st.metric("æ•°æ®ç±»å‹", config.data_type)
                st.write("**æ•°æ®è·¯å¾„**")
                for path in config.data_paths:
                    st.code(path)
                
                st.write("**å…³è”ç­–ç•¥**")
                for policy in config.policies:
                    st.markdown(f"- `{policy}`")
            
            with col_detail:
                st.subheader("å¤„ç†æµæ°´çº¿")
                # æ˜¾ç¤ºæ‰«æå™¨åˆ†ç±»
                for category, scanners in config.scanners.items():
                    if scanners:
                        st.markdown(f"**{category.upper()} æ£€æŸ¥**")
                        st.write(f"æœåŠ¡ç«¯ç‚¹: `{API_MAPPING[category]}`")
                        st.write("æ‰§è¡Œæ‰«æå™¨:")
                        cols = st.columns(3)
                        for i, scanner in enumerate(scanners):
                            cols[i%3].success(f"âœ“ {scanner}")
                
                # æ˜¾ç¤ºAPIè°ƒç”¨é¡ºåº
                st.subheader("æ‰§è¡Œè®¡åˆ’")
                for step, api_call in enumerate(config.api_calls, 1):
                    st.markdown(f"**æ­¥éª¤ {step}** â†’ `{api_call['api']}`")
                    st.json({
                        "æ‰«æå™¨åˆ—è¡¨": api_call['scanners'],
                        "æ•°æ®ç±»å‹": api_call['data_type'],
                        "æ•°æ®è·¯å¾„": config.data_paths
                    })

# æ‰§è¡Œé€»è¾‘å¢å¼º
def execute_policies(configs: List[DataPolicyConfig], payload: dict):
    """æ‰§è¡Œæ‰€æœ‰ç­–ç•¥"""
    results = []
    
    for config in configs:
        # ä»payloadæå–ç›®æ ‡æ•°æ®
        target_data = []
        for path in config.data_paths:
            # å®ç°æ•°æ®è·¯å¾„è§£æï¼ˆç¤ºä¾‹é€»è¾‘ï¼‰
            current = payload
            for key in path.split('.'):
                current = current.get(key, {})
            target_data.append(current)
        
        # æŒ‰é¡ºåºæ‰§è¡ŒAPIè°ƒç”¨
        for api_call in config.api_calls:
            result = {
                "api": api_call["api"],
                "scanners": api_call["scanners"],
                "input_data": target_data,
                "status": "pending"
            }
            
            try:
                # è¿™é‡Œæ·»åŠ å®é™…APIè°ƒç”¨ï¼ˆç¤ºä¾‹ç”¨mockæ•°æ®ï¼‰
                response = {
                    "status": "success",
                    "scanned": api_call["scanners"],
                    "validation_result": "PASS" 
                }
                result.update({
                    "response": response,
                    "status": "success"
                })
            except Exception as e:
                result.update({
                    "error": str(e),
                    "status": "failed"
                })
            
            results.append(result)
    
    return results

# ç•Œé¢é›†æˆ
def manifest_ui():
    # ...ä¿ç•™ä¹‹å‰çš„æ–‡ä»¶ä¸Šä¼ é€»è¾‘...
    
    if uploaded_manifest:
        manifest_content = uploaded_manifest.getvalue().decode()
        configs = process_manifest(manifest_content)
        display_policy_configs(configs)
        
        # æ‰§è¡ŒæŒ‰é’®ç»‘å®š
        if st.button("æ‰§è¡Œç­–ç•¥æµæ°´çº¿"):
            try:
                payload_data = json.loads(payload)  # å‡è®¾payloadæ˜¯JSONå­—ç¬¦ä¸²
                results = execute_policies(configs, payload_data)
                
                st.subheader("æ‰§è¡Œç»“æœ")
                for result in results:
                    with st.container():
                        status_color = "ğŸŸ¢" if result["status"] == "success" else "ğŸ”´"
                        cols = st.columns([1, 4])
                        cols[0].subheader(f"{status_color} {result['status']}")
                        cols[1].write(f"API: `{result['api']}`")
                        cols[1].json(result.get("response", {}))
            except Exception as e:
                st.error(f"æ‰§è¡Œå¤±è´¥: {str(e)}")
