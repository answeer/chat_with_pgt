import os
import cv2
import torch
import numpy as np
import options.options as option
from models import create_model
from utils import util

class DocRestorationInference:
    def __init__(self, opt_path):
        # 初始化配置
        self.opt = option.parse(opt_path, is_train=False)
        self.opt = option.dict_to_nonedict(self.opt)
        
        # 创建模型
        self.model = create_model(self.opt)
        self._load_pretrained_weights()
        self.model.netG.eval()
        
        # 获取设备信息
        self.device = torch.device('cuda' if self.opt['gpu_ids'] else 'cpu')

    def _load_pretrained_weights(self):
        """加载预训练权重"""
        pretrain_path = self.opt['path']['pretrain_model_G']
        print(f'Loading pretrained model from {pretrain_path}')
        
        state_dict = torch.load(pretrain_path, map_location=self.device)
        
        # 处理多GPU训练保存的权重（如果存在module前缀）
        if list(state_dict.keys())[0].startswith('module.'):
            state_dict = {k[7:]: v for k, v in state_dict.items()}  # 去除module前缀
            
        self.model.netG.load_state_dict(state_dict, strict=True)
        print('Successfully loaded pretrained weights')

    def preprocess(self, img):
        """图像预处理流程"""
        # 转换颜色空间
        if self.opt['color'] == 'rgb':
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        
        # 归一化
        if self.opt['input_normalize']:
            img = img.astype(np.float32) / 255.0  # 归一化到[0,1]
            if self.opt['range'] == '-1_1':        # 如果配置要求归一化到[-1,1]
                img = img * 2 - 1
        
        # 转换为Tensor并调整维度
        tensor = torch.from_numpy(img).float().permute(2, 0, 1).unsqueeze(0)  # HWC -> BCHW
        return tensor.to(self.device)

    def postprocess(self, tensor):
        """结果后处理"""
        # 使用项目中的tensor转图像工具
        img = util.tensor2img(tensor)
        
        # 转换回BGR格式保存
        if self.opt['color'] == 'rgb':
            img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
        return img

    def inference_single(self, img_path):
        """单张图像推理"""
        # 读取图像
        assert os.path.exists(img_path), f"Image {img_path} not found"
        img = cv2.imread(img_path)
        original_h, original_w = img.shape[:2]
        
        # 预处理
        lq_tensor = self.preprocess(img)
        
        # 模型推理
        with torch.no_grad():
            self.model.feed_data({'LQ': lq_tensor})
            self.model.test()
            output = self.model.get_current_visuals()['rlt']
        
        # 后处理
        result = self.postprocess(output)
        
        # 保持原始尺寸（如果模型修改了尺寸）
        result = cv2.resize(result, (original_w, original_h))
        return result

    def inference_folder(self, input_dir, output_dir):
        """文件夹批量推理"""
        os.makedirs(output_dir, exist_ok=True)
        img_list = [f for f in os.listdir(input_dir) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
        
        for filename in img_list:
            input_path = os.path.join(input_dir, filename)
            output_path = os.path.join(output_dir, filename)
            
            result = self.inference_single(input_path)
            cv2.imwrite(output_path, result)
            print(f'Saved result to {output_path}')

if __name__ == '__main__':
    # 使用示例
    import argparse
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--opt', type=str, default='options/test/inference_Enhance_MSEC.yml',
                       help='Path to option YAML file')
    parser.add_argument('--input', type=str, required=True,
                       help='Input image/folder path')
    parser.add_argument('--output', type=str, required=True,
                       help='Output folder path')
    args = parser.parse_args()
    
    # 初始化推理器
    restorer = DocRestorationInference(args.opt)
    
    # 判断输入类型
    if os.path.isfile(args.input):
        # 单文件推理
        result = restorer.inference_single(args.input)
        cv2.imwrite(args.output, result)
        print(f'Saved result to {args.output}')
    elif os.path.isdir(args.input):
        # 文件夹批量推理
        restorer.inference_folder(args.input, args.output)
    else:
        raise ValueError("Invalid input path")
