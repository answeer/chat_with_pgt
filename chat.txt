def transform_coordinates(coordinates, matrix):
    """
    Transforms coordinates using the given transformation matrix.
    
    Args:
        coordinates: List of tuples [(x_min, y_min), (x_max, y_max)].
        matrix: Transformation matrix (2x3 for affine, 3x3 for perspective).
        
    Returns:
        Transformed coordinates as a list of tuples [(x_min, y_min), (x_max, y_max)].
    """
    coords = np.array([[x, y, 1] for x, y in coordinates])  # Convert to homogeneous coordinates
    
    # Apply transformation
    if matrix.shape == (2, 3):  # Affine transformation
        transformed_coords = np.dot(np.column_stack([coords[:, :2], np.ones(len(coords))]), matrix.T)
    elif matrix.shape == (3, 3):  # Perspective transformation
        transformed_coords = np.dot(coords, matrix.T)
        transformed_coords = transformed_coords[:, :2] / transformed_coords[:, 2:3]  # Normalize by the homogeneous coordinate (w)

    # Return as a list of tuples
    return transformed_coords[:, :2].tolist()

def draw_bounding_boxes(image, bounding_boxes):
    """
    Draw bounding boxes on the image.
    
    Args:
        image: Aligned image (numpy array).
        bounding_boxes: List of bounding boxes in the form [(x_min, y_min, x_max, y_max), ...].
        
    Returns:
        Image with bounding boxes drawn.
    """
    image_with_boxes = image.copy()
    if len(image_with_boxes.shape) == 2:  # Convert grayscale to BGR for color visualization
        image_with_boxes = cv2.cvtColor(image_with_boxes, cv2.COLOR_GRAY2BGR)

    for box in bounding_boxes:
        x_min, y_min, x_max, y_max = map(int, box)
        cv2.rectangle(image_with_boxes, (x_min, y_min), (x_max, y_max), (0, 255, 0), 2)
    
    return image_with_boxes
