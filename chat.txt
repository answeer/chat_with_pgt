import os
import json
import pandas as pd
import numpy as np
from glob import glob
from tqdm import tqdm
from editdistance import eval as edit_distance

class FUNSDEvaluator:
    def __init__(self, iou_threshold=0.5):
        self.iou_threshold = iou_threshold
        self.metrics = {
            'detection': {'TP': 0, 'FP': 0, 'FN': 0},
            'recognition': {'char_acc': [], 'word_acc': []},
            'linking': {'TP': 0, 'FP': 0, 'FN': 0},
            'errors': []
        }

    def load_annotations(self, annotation_dir):
        """加载所有图片的JSON标注文件"""
        annotations = {}
        json_files = glob(os.path.join(annotation_dir, "*.json"))
        
        for json_path in tqdm(json_files, desc="加载标注"):
            with open(json_path, 'r') as f:
                data = json.load(f)
            
            img_name = os.path.basename(json_path).replace('.json', '')
            annotations[img_name] = []
            
            for item in data['form']:
                # 转换四边形坐标为矩形
                points = np.array(item['box'], dtype=np.int32)
                x_coords = points[::2]
                y_coords = points[1::2]
                rect = [min(x_coords), min(y_coords), 
                       max(x_coords), max(y_coords)]
                
                annotations[img_name].append({
                    'id': item['id'],
                    'rect': rect,
                    'text': item['text'].strip().lower(),
                    'label': item['label'],
                    'linking': item['linking']
                })
        return annotations

    def load_predictions(self, pred_dir):
        """加载模型预测结果"""
        predictions = {}
        excel_files = glob(os.path.join(pred_dir, "*/TextExtraction/*.xlsx"))
        
        for excel_path in tqdm(excel_files, desc="加载预测"):
            img_name = os.path.basename(os.path.dirname(os.path.dirname(excel_path)))
            try:
                df = pd.read_excel(excel_path, header=None)
                predictions[img_name] = []
                for _, row in df.iterrows():
                    predictions[img_name].append({
                        'rect': [int(row[0]), int(row[1]), int(row[2]), int(row[3])],
                        'text': str(row[5]).strip().lower()
                    })
            except Exception as e:
                print(f"Error in {excel_path}: {str(e)}")
        return predictions

    def calculate_iou(self, box_a, box_b):
        """计算两个矩形的IoU"""
        a_x1, a_y1, a_x2, a_y2 = box_a
        b_x1, b_y1, b_x2, b_y2 = box_b
        
        inter_x1 = max(a_x1, b_x1)
        inter_y1 = max(a_y1, b_y1)
        inter_x2 = min(a_x2, b_x2)
        inter_y2 = min(a_y2, b_y2)
        
        if inter_x2 < inter_x1 or inter_y2 < inter_y1:
            return 0.0
        
        inter_area = (inter_x2 - inter_x1) * (inter_y2 - inter_y1)
        area_a = (a_x2 - a_x1) * (a_y2 - a_y1)
        area_b = (b_x2 - b_x1) * (b_y2 - b_y1)
        return inter_area / (area_a + area_b - inter_area + 1e-9)

    def match_boxes(self, gt_boxes, pred_boxes):
        """匹配预测框与标注框"""
        matches = []
        used_gt = set()
        used_pred = set()
        
        # 优先匹配高IoU的预测
        for pred_idx, pred in enumerate(pred_boxes):
            best_iou = 0.0
            best_gt_idx = -1
            for gt_idx, gt in enumerate(gt_boxes):
                if gt_idx in used_gt:
                    continue
                iou = self.calculate_iou(pred['rect'], gt['rect'])
                if iou > best_iou and iou >= self.iou_threshold:
                    best_iou = iou
                    best_gt_idx = gt_idx
            if best_gt_idx != -1:
                matches.append( (best_gt_idx, pred_idx) )
                used_gt.add(best_gt_idx)
                used_pred.add(pred_idx)
        
        return matches, used_gt, used_pred

    def evaluate_linking(self, img_name, gt_boxes, pred_matches):
        """评估关联关系"""
        # 构建预测关联映射
        pred_links = set()
        for gt_idx, pred_idx in pred_matches:
            for link in gt_boxes[gt_idx]['linking']:
                src_id, tgt_id = link
                # 查找匹配的预测ID
                tgt_pred = next((p for g,p in pred_matches if g == tgt_id), None)
                if tgt_pred is not None:
                    pred_links.add( (pred_idx, tgt_pred) )
        
        # 计算链接指标
        gt_links = set()
        for gt in gt_boxes:
            for link in gt['linking']:
                gt_links.add( tuple(link) )
        
        tp = len(pred_links & gt_links)
        fp = len(pred_links - gt_links)
        fn = len(gt_links - pred_links)
        
        self.metrics['linking']['TP'] += tp
        self.metrics['linking']['FP'] += fp
        self.metrics['linking']['FN'] += fn

    def evaluate_image(self, img_name, gt_boxes, pred_boxes):
        """评估单张图片"""
        # 检测与识别评估
        matches, used_gt, used_pred = self.match_boxes(gt_boxes, pred_boxes)
        
        # 统计检测指标
        tp = len(matches)
        fp = len(pred_boxes) - tp
        fn = len(gt_boxes) - tp
        self.metrics['detection']['TP'] += tp
        self.metrics['detection']['FP'] += fp
        self.metrics['detection']['FN'] += fn
        
        # 识别指标
        for gt_idx, pred_idx in matches:
            gt_text = gt_boxes[gt_idx]['text']
            pred_text = pred_boxes[pred_idx]['text']
            
            # 字符级准确率
            char_acc = 1 - edit_distance(gt_text, pred_text)/max(len(gt_text), len(pred_text))
            self.metrics['recognition']['char_acc'].append(char_acc)
            
            # 单词级准确率
            self.metrics['recognition']['word_acc'].append(int(gt_text == pred_text))
            
            # 记录错误
            if gt_text != pred_text:
                self.metrics['errors'].append({
                    'image': img_name,
                    'gt': gt_text,
                    'pred': pred_text,
                    'label': gt_boxes[gt_idx]['label']
                })
        
        # 关联关系评估
        self.evaluate_linking(img_name, gt_boxes, matches)

    def generate_report(self):
        """生成完整评估报告"""
        # 检测指标
        det = self.metrics['detection']
        det_precision = det['TP'] / (det['TP'] + det['FP'] + 1e-9)
        det_recall = det['TP'] / (det['TP'] + det['FN'] + 1e-9)
        det_f1 = 2 * (det_precision * det_recall) / (det_precision + det_recall + 1e-9)
        
        # 识别指标
        rec = self.metrics['recognition']
        char_acc = np.mean(rec['char_acc']) if rec['char_acc'] else 0
        word_acc = np.mean(rec['word_acc']) if rec['word_acc'] else 0
        
        # 关联指标
        link = self.metrics['linking']
        link_precision = link['TP'] / (link['TP'] + link['FP'] + 1e-9)
        link_recall = link['TP'] / (link['TP'] + link['FN'] + 1e-9)
        link_f1 = 2 * (link_precision * link_recall) / (link_precision + link_recall + 1e-9)
        
        # 错误分析
        error_df = pd.DataFrame(self.metrics['errors'])
        error_analysis = {
            'total': len(error_df),
            'by_label': error_df.groupby('label').size().to_dict(),
            'top_errors': error_df.groupby(['gt', 'pred']).size().nlargest(5).to_dict()
        }
        
        return {
            'detection': {
                'precision': round(det_precision, 4),
                'recall': round(det_recall, 4),
                'f1': round(det_f1, 4)
            },
            'recognition': {
                'char_accuracy': round(char_acc, 4),
                'word_accuracy': round(word_acc, 4)
            },
            'linking': {
                'precision': round(link_precision, 4),
                'recall': round(link_recall, 4),
                'f1': round(link_f1, 4)
            },
            'errors': error_analysis
        }

if __name__ == "__main__":
    evaluator = FUNSDEvaluator(iou_threshold=0.5)
    
    # 加载数据（示例路径）
    annotations = evaluator.load_annotations("path/to/funsd/annotations/")
    predictions = evaluator.load_predictions("path/to/predictions/")
    
    # 执行评估
    for img_name in tqdm(annotations, desc="评估进度"):
        if img_name in predictions:
            evaluator.evaluate_image(img_name, annotations[img_name], predictions[img_name])
    
    # 生成报告
    report = evaluator.generate_report()
    
    # 打印结果
    print("\n=== 综合评估报告 ===")
    print(f"[检测] Precision: {report['detection']['precision']}, Recall: {report['detection']['recall']}, F1: {report['detection']['f1']}")
    print(f"[识别] 字符准确率: {report['recognition']['char_accuracy']}, 单词准确率: {report['recognition']['word_accuracy']}")
    print(f"[关联] Precision: {report['linking']['precision']}, Recall: {report['linking']['recall']}, F1: {report['linking']['f1']}")
    
    print("\n=== 错误分析 ===")
    print(f"总错误数: {report['errors']['total']}")
    print("按标签分布:")
    for label, count in report['errors']['by_label'].items():
        print(f"  {label}: {count}")
    print("\n常见错误Top5:")
    for (gt, pred), count in report['errors']['top_errors'].items():
        print(f"  '{gt}' → '{pred}': {count}次")
