def draw_bounding_boxes(image, bounding_boxes):
    """
    Draw bounding boxes on the image.
    
    Args:
        image: Aligned image (numpy array).
        bounding_boxes: List of bounding boxes in the form [(x_min, y_min, x_max, y_max), ...].
        
    Returns:
        Image with bounding boxes drawn.
    """
    image_with_boxes = image.copy()
    if len(image_with_boxes.shape) == 2:  # Convert grayscale to BGR for color visualization
        image_with_boxes = cv2.cvtColor(image_with_boxes, cv2.COLOR_GRAY2BGR)

    for box in bounding_boxes:
        x_min, y_min, x_max, y_max = map(int, box)
        cv2.rectangle(image_with_boxes, (x_min, y_min), (x_max, y_max), (0, 255, 0), 2)
    
    return image_with_boxes

def process_transfer_slips(template_path, filled_slip_folder, excel_path, output_dir):
    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
    filled_slip_paths = [os.path.join(filled_slip_folder, f) for f in os.listdir(filled_slip_folder)]
    os.makedirs(output_dir, exist_ok=True)

    df = pd.read_excel(excel_path)

    for idx, slip_path in enumerate(tqdm(filled_slip_paths, desc="Processing Transfer Slips")):
        target = cv2.imread(slip_path, cv2.IMREAD_GRAYSCALE)
        file_name = os.path.basename(slip_path)

        try:
            aligned, matrix = align_images(template, target)
            overlay = overlay_images(template, aligned)

            aligned_path = os.path.join(output_dir, f"aligned_{idx + 1}.png")
            overlay_path = os.path.join(output_dir, f"overlay_{idx + 1}.png")
            cv2.imwrite(aligned_path, aligned)
            cv2.imwrite(overlay_path, overlay)

            matched_name = find_match(file_name, df['name'].values)
            if matched_name:
                matched_rows = df[df['name'] == matched_name]
                bounding_boxes = []
                updated_rows = []

                for _, row in matched_rows.iterrows():
                    coordinates = [(row['x-min'], row['y-min']), (row['x-max'], row['y-max'])]
                    transformed_coordinates = transform_coordinates(coordinates, matrix)

                    bounding_boxes.append(
                        [transformed_coordinates[0][0], transformed_coordinates[0][1],
                         transformed_coordinates[1][0], transformed_coordinates[1][1]]
                    )

                    updated_rows.append({
                        'name': row['name'],
                        'x-min': transformed_coordinates[0][0],
                        'y-min': transformed_coordinates[0][1],
                        'x-max': transformed_coordinates[1][0],
                        'y-max': transformed_coordinates[1][1]
                    })

                updated_df = pd.DataFrame(updated_rows)
                df.update(updated_df)

                # Draw bounding boxes on
