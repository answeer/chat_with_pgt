import pandas as pd
from scipy.spatial import distance

def merge_text_blocks(df, horizontal_threshold=0.3, vertical_threshold=0.5):
    # Calculate geometry features
    df['x_center'] = (df['x_min'] + df['x_max']) / 2
    df['y_center'] = (df['y_min'] + df['y_max']) / 2
    df['width'] = df['x_max'] - df['x_min']
    df['height'] = df['y_max'] - df['y_min']
    
    # Compute averages
    avg_width = df['width'].mean()
    avg_height = df['height'].mean()
    
    # Cluster blocks
    blocks = []
    visited = set()
    
    for i, row in df.iterrows():
        if i in visited:
            continue
            
        current_block = [i]
        visited.add(i)
        queue = [i]
        
        while queue:
            current_idx = queue.pop(0)
            current_row = df.loc[current_idx]
            
            for j, other_row in df.iterrows():
                if j in visited:
                    continue
                
                # Calculate Euclidean distance
                dist = distance.euclidean(
                    (current_row['x_center'], current_row['y_center']),
                    (other_row['x_center'], other_row['y_center'])
                )
                
                # Horizontal proximity check
                horizontal_close = (
                    abs(current_row['y_center'] - other_row['y_center']) < avg_height * horizontal_threshold and
                    dist < avg_width * (1 + horizontal_threshold)
                )
                
                # Vertical proximity check
                vertical_close = (
                    abs(current_row['x_center'] - other_row['x_center']) < avg_width * vertical_threshold and
                    dist < avg_height * (1 + vertical_threshold)
                )
                
                if horizontal_close or vertical_close:
                    current_block.append(j)
                    visited.add(j)
                    queue.append(j)
        
        blocks.append(current_block)
    
    return blocks

def sort_text_boxes(block_df):
    if block_df.empty:
        return block_df
        
    avg_height = block_df['height'].mean()
    row_threshold = avg_height * 0.5
    sorted_block = block_df.sort_values('y_min')
    
    rows = []
    current_row = []
    baseline = None  # Baseline y_min for current row
    
    for _, row in sorted_block.iterrows():
        if baseline is None:
            current_row.append(row)
            baseline = row['y_min']
        else:
            # Compare to row's baseline
            if row['y_min'] <= baseline + row_threshold:
                current_row.append(row)
            else:
                # Finalize current row
                current_row_sorted = sorted(current_row, key=lambda r: r['x_min'])
                rows.append(current_row_sorted)
                current_row = [row]
                baseline = row['y_min']
    
    if current_row:
        current_row_sorted = sorted(current_row, key=lambda r: r['x_min'])
        rows.append(current_row_sorted)
    
    # Flatten into DataFrame
    sorted_boxes = [item for row in rows for item in row]
    return pd.DataFrame(sorted_boxes)

def generate_block_text(block_df):
    # Direct concatenation after proper sorting
    return ''.join(block_df['text'])

def process_ocr_excel(file_path):
    df = pd.read_excel(file_path)
    text_blocks = merge_text_blocks(df)
    
    # Sort blocks by vertical position (top-first)
    text_blocks_sorted = sorted(
        text_blocks,
        key=lambda indices: df.loc[indices, 'y_min'].min()
    )
    
    results = []
    for block_indices in text_blocks_sorted:
        block_df = df.loc[block_indices]
        sorted_block = sort_text_boxes(block_df)
        block_text = generate_block_text(sorted_block)
        results.append(block_text)
    
    return " ".join(results)

# Example usage
result = process_ocr_excel(r"your_file_path.xlsx")
