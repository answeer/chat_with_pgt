def merge_text_blocks(df, horizontal_threshold=0.5, vertical_threshold=0.8):
    # Existing merge code with optimized thresholds
    # ... [same as original, with optimized threshold values] ...

def sort_text_boxes(block_df):
    # Sort with document-specific thresholds
    avg_height = block_df['height'].mean()
    row_threshold = avg_height * 0.3  # Tighter vertical grouping
    
    rows = []
    sorted_block = block_df.sort_values('y_min')
    
    current_row = []
    last_y_min = None
    
    for _, row in sorted_block.iterrows():
        if last_y_min is None:
            current_row.append(row)
            last_y_min = row['y_min']
        else:
            # Group in same row if vertically close
            if abs(row['y_center'] - last_y_min) < row_threshold:
                current_row.append(row)
            else:
                # Sort left-to-right within row
                current_row_sorted = sorted(current_row, key=lambda r: r['x_min'])
                rows.append(current_row_sorted)
                current_row = [row]
            last_y_min = row['y_center']  # Use center for better accuracy
    
    if current_row:
        current_row_sorted = sorted(current_row, key=lambda r: r['x_min'])
        rows.append(current_row_sorted)
    
    # Flatten rows while preserving order
    return pd.DataFrame([item for row in rows for item in row])

def generate_block_text(block_df):
    # Bill of lading specific reconstruction rules
    left_column_threshold = block_df['x_center'].quantile(0.3)
    document_text = []
    
    current_section = []
    last_y = None
    
    for _, row in block_df.sort_values(['y_center', 'x_center']).iterrows():
        # Detect section breaks (vertical gaps)
        if last_y and (row['y_center'] - last_y) > block_df['height'].mean() * 1.5:
            document_text.append(" ".join(current_section))
            current_section = []
        
        # Two-column formatting
        if row['x_center'] < left_column_threshold:
            current_section.append(row['text'])
        else:
            # Add key-value separator for right column
            if current_section and not current_section[-1].endswith(':'):
                current_section.append(":")
            current_section.append(row['text'])
        
        last_y = row['y_center']
    
    if current_section:
        document_text.append(" ".join(current_section))
    
    return "\n".join(document_text)

def process_ocr_excel(file_path):
    df = pd.read_excel(file_path)
    
    # Pre-filter low confidence detections
    df = df[df['conf'] > 85]  # Remove low-confidence artifacts
    
    text_blocks = merge_text_blocks(df)
    
    # Sort blocks by vertical position
    block_positions = []
    for block_indices in text_blocks:
        block_df = df.loc[block_indices]
        block_top = block_df['y_min'].min()
        block_left = block_df['x_min'].min()
        block_positions.append((block_top, block_left, block_df))
    
    results = []
    for _, _, block_df in sorted(block_positions, key=lambda x: (x[0], x[1])):
        sorted_block = sort_text_boxes(block_df)
        block_text = generate_block_text(sorted_block)
        results.append(block_text)
    
    return "\n\n".join(results)
