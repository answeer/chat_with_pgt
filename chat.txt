from llm_sanitation.scanners.scanner_base import Scanner
from llm_sanitation.utils.models import *
import json
import numpy as np
import re
from llm_sanitation.logging.logging_setup import LogUtil, LogType, LogLevel

class JsonValidator(Scanner):
    """
    A Scanner class for validating JSON payloads against a set of mandated keys and patterns.

    This class checks if the provided JSON payload adheres to the required structure and 
    contains the necessary key-value pairs that match specified patterns.

    Attributes:
        mandate_checks (dict): A dictionary containing the keys and corresponding regex patterns 
                               to validate against the JSON payload.

    Methods:
        get_value(payload: dict, keys: str) -> Any:
            Retrieves the value from the nested JSON payload using dot notation.

        check_mandate_keys(payload: dict) -> tuple:
            Validates the JSON payload against the mandated keys and patterns, returning a prediction and score.

        check_json_format(payload: Any) -> tuple:
            Checks if the given payload is a valid JSON format, returning the parsed JSON or an error.

        predict(payload: Any) -> tuple:
            Main prediction method that validates the JSON payload, combining format and mandate checks.

        format_response() -> None:
            Formats the scanner's response by assigning the prediction and score to the response dictionary.
    """

    def __init__(self, **kwargs):
        """
        Initializes the JsonValidator scanner.

        Args:
            mandate_checks (dict): A dictionary of keys and regex patterns to validate against the JSON payload.
        """
        mandate_checks = kwargs["mandate_keys"]
        super().__init__("json_validator", 1, mandate_checks=mandate_checks)

    def get_value(self, payload, keys):
        """
        Retrieves the value from the nested JSON payload using dot notation.

        Args:
            payload (dict): The JSON object to retrieve the value from.
            keys (str): The dot-separated key string indicating the path in the JSON object.

        Returns:
            Any: The value found at the specified path, or None if the key does not exist.
        """
        keys = keys.split(".")
        value = payload
        for key in keys:
            if isinstance(value, dict):
                value = value.get(key)
            else:
                return None
        return value

    def check_mandate_keys(self, payload):
        """
        Validates the JSON payload against the mandated keys and patterns.

        Args:
            payload (dict): The JSON object to validate.

        Returns:
            tuple: A tuple containing a list of prediction strings and the average score.
        """
        self.mandate_keys = self._kwargs["mandate_checks"].keys()

        predict = []
        score = []
        try:
            for mandate_key in self.mandate_keys:
                mandate_pattern = self._kwargs["mandate_checks"].get(mandate_key, [])
                pattern = re.compile(mandate_pattern)
                
                value = self.get_value(payload, mandate_key)

                if value is None:
                    score.append(0)
                    predict.append("Key `{}` not found".format(mandate_key))

                elif re.match(pattern, value):
                    score.append(1)
                else:
                    score.append(0)
                    predict.append("For Key `{}` value {} is not in the correct pattern.".format(mandate_key, value))

        except Exception as e:
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, e)
            predict.append("Error occurred: {}".format(e))
            score.append(0)

        return predict, np.mean(score)

    def check_json_format(self, payload):
        """
        Validates that a value is parseable as valid JSON.

        Args:
            payload (Any): The data to check for JSON format.

        Returns:
            tuple: A tuple containing the parsed JSON object and any error that occurred during parsing.
        """
        stringified = payload
        parsed_payload, error = (None, None)
        try:
            if not isinstance(payload, str):
                stringified = json.dumps(payload)

            parsed_payload = json.loads(stringified)
        except json.decoder.JSONDecodeError as json_error:
            error = json_error
        except TypeError as type_error:
            error = type_error
        return parsed_payload, error

    def predict(self, payload):
        """
        Main prediction method that validates the JSON payload.

        Args:
            payload (Any): The JSON object or string to validate.

        Returns:
            tuple: A tuple containing a list of prediction strings or error and a score.
        """
        parsed_payload, error = self.check_json_format(payload)
        if error is not None:
            score = 0
            predict = error
            return predict, score
        else:
            predict, score = self.check_mandate_keys(parsed_payload)
        return predict, score

    def format_response(self):
        """
        Formats the scanner's response.

        Assigns the prediction and score to the response dictionary, making them available for 
        further processing or output.
        """
        self.response["prediction"]["json_validator"] = self.pred[0]
        self.response["score"] = self.pred[1]
