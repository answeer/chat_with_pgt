def transform_coordinates(coordinates, matrix):
    """
    Transforms coordinates using the given transformation matrix.
    
    Args:
        coordinates: List of tuples [(x_min, y_min), (x_max, y_max)].
        matrix: Transformation matrix (2x3 for affine, 3x3 for perspective).
        
    Returns:
        Transformed coordinates as a list of tuples [(x_min, y_min), (x_max, y_max)].
    """
    coords = np.array([[x, y, 1] for x, y in coordinates])  # Convert to homogeneous coordinates
    if matrix.shape == (2, 3):  # Affine transformation
        transformed_coords = np.dot(matrix, coords.T).T  # Perform the affine transformation
    elif matrix.shape == (3, 3):  # Perspective transformation
        transformed_coords = np.dot(matrix, coords.T).T  # Perform the perspective transformation
        transformed_coords = transformed_coords[:, :2] / transformed_coords[:, 2:3]  # Normalize by w

    return transformed_coords[:, :2]

def draw_bounding_boxes(image, bounding_boxes):
    """
    Draw bounding boxes on the image.
    
    Args:
        image: Aligned image (numpy array).
        bounding_boxes: List of bounding boxes in the form [(x_min, y_min, x_max, y_max), ...].
        
    Returns:
        Image with bounding boxes drawn.
    """
    image_with_boxes = image.copy()
    if len(image_with_boxes.shape) == 2:  # Convert grayscale to BGR for color visualization
        image_with_boxes = cv2.cvtColor(image_with_boxes, cv2.COLOR_GRAY2BGR)

    for box in bounding_boxes:
        x_min, y_min, x_max, y_max = map(int, box)
        cv2.rectangle(image_with_boxes, (x_min, y_min), (x_max, y_max), (0, 255, 0), 2)
    
    return image_with_boxes
