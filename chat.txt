# 新增数据结构
from dataclasses import dataclass
from typing import Dict, List

@dataclass
class DataPolicyConfig:
    data_paths: List[str]       # 数据路径列表 ["params.service_path"]
    data_type: str              # 数据类型 "text"
    policies: List[str]         # 关联策略 ["001_free_text_bounding_policy"]
    scanners: Dict[str, List]  # 分类后的扫描器 {"bounding": ["TokenLimit", ...]}
    api_calls: List[Dict]       # 需要调用的API列表

# 增强的manifest处理逻辑
def process_manifest(manifest_content: str) -> List[DataPolicyConfig]:
    """生成每个data配置项的处理方案"""
    configs = []
    manifest_data = parse_manifest(manifest_content)
    
    for agent_name, agent_config in manifest_data.items():
        input_data = agent_config.get('guardrails', {}).get('input_data', {})
        
        for data_type, type_configs in input_data.items():
            for config in type_configs:
                # 创建配置实例
                policy_config = DataPolicyConfig(
                    data_paths=config.get('data', []),
                    data_type=data_type,
                    policies=config.get('policies', []),
                    scanners={},
                    api_calls=[]
                )
                
                # 处理策略映射
                scanners = process_policies(policy_config.policies)
                policy_config.scanners = scanners
                
                # 生成API调用计划
                for category in ['bounding', 'sanitation', 'validator']:
                    if scanners.get(category):
                        policy_config.api_calls.append({
                            "api": API_MAPPING[category],
                            "scanners": scanners[category],
                            "data_type": data_type
                        })
                
                configs.append(policy_config)
    
    return configs

# 增强的UI展示
def display_policy_configs(configs: List[DataPolicyConfig]):
    """可视化展示每个data配置项的处理流程"""
    for idx, config in enumerate(configs, 1):
        with st.expander(f"Data配置项 #{idx} [{config.data_type}]", expanded=True):
            # 基本信息列
            col_meta, col_detail = st.columns([1, 3])
            
            with col_meta:
                st.metric("数据类型", config.data_type)
                st.write("**数据路径**")
                for path in config.data_paths:
                    st.code(path)
                
                st.write("**关联策略**")
                for policy in config.policies:
                    st.markdown(f"- `{policy}`")
            
            with col_detail:
                st.subheader("处理流水线")
                # 显示扫描器分类
                for category, scanners in config.scanners.items():
                    if scanners:
                        st.markdown(f"**{category.upper()} 检查**")
                        st.write(f"服务端点: `{API_MAPPING[category]}`")
                        st.write("执行扫描器:")
                        cols = st.columns(3)
                        for i, scanner in enumerate(scanners):
                            cols[i%3].success(f"✓ {scanner}")
                
                # 显示API调用顺序
                st.subheader("执行计划")
                for step, api_call in enumerate(config.api_calls, 1):
                    st.markdown(f"**步骤 {step}** → `{api_call['api']}`")
                    st.json({
                        "扫描器列表": api_call['scanners'],
                        "数据类型": api_call['data_type'],
                        "数据路径": config.data_paths
                    })

# 执行逻辑增强
def execute_policies(configs: List[DataPolicyConfig], payload: dict):
    """执行所有策略"""
    results = []
    
    for config in configs:
        # 从payload提取目标数据
        target_data = []
        for path in config.data_paths:
            # 实现数据路径解析（示例逻辑）
            current = payload
            for key in path.split('.'):
                current = current.get(key, {})
            target_data.append(current)
        
        # 按顺序执行API调用
        for api_call in config.api_calls:
            result = {
                "api": api_call["api"],
                "scanners": api_call["scanners"],
                "input_data": target_data,
                "status": "pending"
            }
            
            try:
                # 这里添加实际API调用（示例用mock数据）
                response = {
                    "status": "success",
                    "scanned": api_call["scanners"],
                    "validation_result": "PASS" 
                }
                result.update({
                    "response": response,
                    "status": "success"
                })
            except Exception as e:
                result.update({
                    "error": str(e),
                    "status": "failed"
                })
            
            results.append(result)
    
    return results

# 界面集成
def manifest_ui():
    # ...保留之前的文件上传逻辑...
    
    if uploaded_manifest:
        manifest_content = uploaded_manifest.getvalue().decode()
        configs = process_manifest(manifest_content)
        display_policy_configs(configs)
        
        # 执行按钮绑定
        if st.button("执行策略流水线"):
            try:
                payload_data = json.loads(payload)  # 假设payload是JSON字符串
                results = execute_policies(configs, payload_data)
                
                st.subheader("执行结果")
                for result in results:
                    with st.container():
                        status_color = "🟢" if result["status"] == "success" else "🔴"
                        cols = st.columns([1, 4])
                        cols[0].subheader(f"{status_color} {result['status']}")
                        cols[1].write(f"API: `{result['api']}`")
                        cols[1].json(result.get("response", {}))
            except Exception as e:
                st.error(f"执行失败: {str(e)}")
