def transform_coordinates(coordinates, matrix, transform_type="affine"):
    """
    Transforms coordinates using the given transformation matrix.
    
    Args:
        coordinates: List of tuples [(x_min, y_min), (x_max, y_max)].
        matrix: Transformation matrix (2x3 for affine, 3x3 for perspective).
        transform_type: Type of transformation ("affine" or "perspective").
        
    Returns:
        Transformed coordinates as a list of tuples [(x_min, y_min), (x_max, y_max)].
    """
    coords = np.array([[x, y, 1] for x, y in coordinates])  # Convert to homogeneous coordinates
    
    if transform_type == "affine":
        # For affine transformation (2x3 matrix)
        transformed_coords = np.dot(coords[:, :2], matrix[:, :2].T) + matrix[:, 2]
    elif transform_type == "perspective":
        # For perspective transformation (3x3 matrix)
        transformed_coords = np.dot(coords, matrix.T)
        transformed_coords = transformed_coords[:, :2] / transformed_coords[:, 2:]  # Normalize by w
    
    # Return transformed coordinates as a list of tuples
    return transformed_coords.tolist()

def draw_bounding_boxes(image, bounding_boxes):
    """
    Draw bounding boxes on the image.
    
    Args:
        image: Aligned image (numpy array).
        bounding_boxes: List of bounding boxes in the form [(x_min, y_min, x_max, y_max), ...].
        
    Returns:
        Image with bounding boxes drawn.
    """
    image_with_boxes = image.copy()
    if len(image_with_boxes.shape) == 2:  # Convert grayscale to BGR for color visualization
        image_with_boxes = cv2.cvtColor(image_with_boxes, cv2.COLOR_GRAY2BGR)

    for box in bounding_boxes:
        x_min, y_min, x_max, y_max = map(int, box)
        cv2.rectangle(image_with_boxes, (x_min, y_min), (x_max, y_max), (0, 255, 0), 2)
    
    return image_with_boxes
