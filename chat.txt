from llm_sanitation.utils.callback import Callback
from llm_sanitation.utils.checks import Checks
from llm_sanitation.utils.error_codes import ERROR_CODE_DICT

class Action:
    def __init__(self):
        self.combined_result = []
        self.nstp_result = []

    def run_scanner(self, data, scanner_nm, param, **kwargs):
        """Dynamically imports and runs the specified scanner with provided parameters."""
        try:
            scanners = __import__("llm_sanitation.scanners", fromlist=[scanner_nm])
            scanner = getattr(scanners, scanner_nm)
        except (ImportError, AttributeError) as e:
            raise ImportError(f"Failed to import scanner: {scanner_nm}. Error: {e}")

        scanner_obj = scanner(**param)
        self.response.start_time_analysis(scanner_nm)

        # Run the scanner's validation method and record the result
        result = scanner_obj.validate(data, **kwargs)

        self.response.end_time_analysis(scanner_nm)
        self.combined_result.append(result)
        self.nstp_result.append(result.get("NSTP"))

        return result

    def get_result(self):
        """Returns all combined results from the scanners."""
        return self.combined_result

    def get_nstp_result(self):
        """Returns NSTP results from each scanner."""
        return self.nstp_result

    def check_response_status(self):
        """Checks the response status and handles failure by returning error details."""
        if self.response.status == "failed":
            response_json = self.response.return_response()
            error_code = response_json["scanner_info"]["error_code"]
            error_message = response_json["scanner_info"]["error_message"]
            return None, error_code, error_message
        return None, None, None

    def handle_exception(self, error_code, error_message):
        """Handles exceptions by forming and returning an error response."""
        self.response.form_response(error_code, error_message)
        return self.response.return_response()

    def run_action(self, execution_plan, data, scanner_type, save_path, **kwargs):
        """Executes the scanning process based on the provided execution plan and scanner type."""
        try:
            # Initialize the callback object for the response tracking
            self.response = Callback(scanner_type, save_path, **kwargs)
            check = Checks(self.response)

            # Pre-validation checks based on scanner type
            if scanner_type == "file_bounding":
                check.file_exists(data)
            elif scanner_type == "image_bounding":
                check.check_image(data)
            elif scanner_type == "numeric_bounding":
                check.check_numeric(data)
            elif scanner_type == "text_bounding":
                check.check_text(data)
            else:
                return self.handle_exception("FRDIOS0005", ERROR_CODE_DICT["FRDIOS0005"].format(str(scanner_type)))

            # Check response status after initial validation
            _, error_code, error_message = self.check_response_status()
            if error_code:
                return None, error_code, error_message

            # Run each scanner in the execution plan
            for scanner_nm, param in execution_plan.items():
                result = self.run_scanner(data, scanner_nm, param, **kwargs)
                # Update data if sanitized_data is not None
                data = result.get("sanitized_data", data)

            # Form and return the final response
            self.response.form_response()
            return self.response.return_response()

        except Exception as e:
            # Handle any exceptions and return a formatted error response
            error_code = "FRDIOS9000"
            error_message = ERROR_CODE_DICT[error_code].format(str(e))
            return self.handle_exception(error_code, error_message)

if __name__ == "__main__":
    payload = {
        "job_params": {
            "jobid": "JID-54ca58ba-c495-11ed-b20c-0a586e830578",
            "app_name": "synthesizer",
            "use_case": "aadhar_redact",
            "save_path": r"C:\Users\1657820\Desktop\51433-swoosh-io-bounding",
        },
        "service_params": {
            "callback_url": "http://service-swoosh-orchestrator.swoosh-dev.svc.cluster.local:8889/api/v1/callback",
            "job_object": {
                "io": "i",
                "policy_id": "policy_00001",
                "scanner_type": "file_bounding",
                "execution_plan": {
                    "EncryptionDetector": {},
                    "FormatCheck": {'format_list': ['jpg', 'png', 'jpeg', 'PNG', 'pdf']},
                    "SoftwareCheck": {'software_blacklist': ["", "Photoshop", "Corel", "PhotoScape", "PhotoPlus", "GIMP", 
                                                             "Pixelmator", "Illustrator", "Windows Photo Editor", "ilovepdf"]}
                },
                "data": r"llm_sanitation\scanners\file_bounding\software_check\tests\LIME.pdf"
            }
        }
    }

    kwargs = {
        "job_id": payload["job_params"].get("jobid", "NA"),
        "use_case": payload["job_params"].get("use_case", "NA"),
        "io": payload["service_params"]["job_object"].get("io", "NA"),
        "policy_id": payload["service_params"]["job_object"].get("policy_id", "NA"),
    }

    execution_plan = payload["service_params"]["job_object"].get("execution_plan", {})
    data = payload["service_params"]["job_object"].get("data", "")
    save_path = payload["job_params"].get("save_path", "NA")
    scanner_type = payload["service_params"]["job_object"].get("scanner_type", "NA")

    action_obj = Action()
    action_obj.run_action(execution_plan, data, scanner_type, save_path, **kwargs)
    print("Action completed")
    print(action_obj.get_result())
