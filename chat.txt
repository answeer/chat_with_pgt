from neo4j import GraphDatabase
import re

# æ–°å¢æ•°æ®æ¸…æ´—å‡½æ•°
def sanitize_name(name):
    """ç»Ÿä¸€åç§°æ ¼å¼ï¼šå»é™¤é¦–å°¾ç©ºæ ¼ã€è½¬å°å†™ã€åˆå¹¶å†…éƒ¨ç©ºæ ¼"""
    return re.sub(r'\s+', ' ', name.strip()).lower()

with open("neo4j\\llm_inferred.txt", "r") as f:
    data = f.read()

# å¼ºåŒ–æ­£åˆ™è¡¨è¾¾å¼ï¼ˆæ”¯æŒä¸­æ–‡ç­‰æ‰©å±•å­—ç¬¦ï¼‰
pattern = re.compile(r"(\w+):([\w\s&(),'\-]+?)--(\w+)-->(\w+):([\w\s&(),'\-]+)")

def parse_line(line):
    match = pattern.match(line.strip())
    if not match:
        return None
    
    # æ–°å¢æ•°æ®æ ‡å‡†åŒ–å¤„ç†
    item = {
        "from_label": match.group(1).strip(),
        "from_name": sanitize_name(match.group(2)),
        "rel_type": match.group(3).strip().upper(),  # å…³ç³»ç±»å‹ç»Ÿä¸€å¤§å†™
        "to_label": match.group(4).strip(),
        "to_name": sanitize_name(match.group(5))
    }
    
    # å¼ºåŒ–è¿‡æ»¤é€»è¾‘
    if (item["from_label"] == item["to_label"] and 
        item["from_name"] == item["to_name"]):
        print(f"âš ï¸ è¿‡æ»¤è‡ªç¯: {item}")
        return None
    
    return item

# åˆ›å»ºå”¯ä¸€çº¦æŸï¼ˆé˜²æ­¢ä¸åŒèŠ‚ç‚¹åŒåï¼‰
def create_constraints(tx):
    # åˆ›å»ºå”¯ä¸€æ€§çº¦æŸï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
    tx.run("CREATE CONSTRAINT IF NOT EXISTS FOR (n:Framework) REQUIRE n.name IS UNIQUE")
    tx.run("CREATE CONSTRAINT IF NOT EXISTS FOR (n:Policy) REQUIRE n.name IS UNIQUE")
    tx.run("CREATE CONSTRAINT IF NOT EXISTS FOR (n:Standard) REQUIRE n.name IS UNIQUE")

driver = GraphDatabase.driver(uri, auth=(username, password))

# åœ¨åˆå§‹åŒ–é˜¶æ®µåˆ›å»ºçº¦æŸ
with driver.session() as session:
    session.execute_write(create_constraints)

def create_node_rel(tx, item):
    # ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢æ³¨å…¥
    query = """
        MERGE (a:`%s` {name: $from_name})
        MERGE (b:`%s` {name: $to_name})
        // æ–°å¢å…¨è·¯å¾„æ£€æŸ¥
        WITH a, b 
        WHERE a <> b AND NOT exists((a)-[:%s]->(b))
        CREATE (a)-[r:`%s`]->(b)
    """ % (
        item["from_label"], 
        item["to_label"],
        item["rel_type"],  # é˜²æ­¢é‡å¤å…³ç³»
        item["rel_type"]
    )
    
    try:
        result = tx.run(query, 
                       from_name=item["from_name"],
                       to_name=item["to_name"])
        summary = result.consume()
        if summary.counters.relationships_created == 0:
            print(f"ğŸ” å…³ç³»å·²å­˜åœ¨: {item}")
    except Exception as e:
        print(f"âŒ åˆ›å»ºå¤±è´¥: {item} - {str(e)}")

# æ‰¹é‡å¤„ç†æ—¶æ·»åŠ äº‹åŠ¡é‡è¯•æœºåˆ¶
from neo4j import TransactionError

with driver.session() as session:
    lines = [line for line in data.split('\n') if line.strip()]
    
    for i in range(0, len(lines), batch_size):
        batch = lines[i:i+batch_size]
        valid_data = []
        
        for line in batch:
            item = parse_line(line)
            if item:
                valid_data.append(item)
        
        # å¸¦é‡è¯•çš„äº‹åŠ¡æ‰§è¡Œ
        max_retries = 3
        for attempt in range(max_retries):
            try:
                session.execute_write(
                    lambda tx: [create_node_rel(tx, item) for item in valid_data]
                )
                break
            except TransactionError as e:
                if attempt == max_retries - 1:
                    print(f"âŒ æ‰¹å¤„ç†å¤±è´¥: {e}")
                else:
                    print(f"ğŸ”„ é‡è¯•ç¬¬{attempt+1}æ¬¡...")
        
        print(f"âœ… å·²å¤„ç† {min(i+batch_size, len(lines))}/{len(lines)} è¡Œ")

# æ¸…ç†ç°æœ‰è‡ªç¯çš„åº”æ€¥æ–¹æ¡ˆ
cleanup_query = """
MATCH (a)-[r]->(a)
DELETE r
"""

with driver.session() as session:
    result = session.run(cleanup_query)
    print(f"å·²æ¸…ç† {result.consume().counters.relationships_deleted} ä¸ªè‡ªç¯å…³ç³»")

driver.close()
