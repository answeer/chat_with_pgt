from collections import defaultdict
import os
from llm_sanitation.agent.utils.defaults import scanner_default
from llm_sanitation.agent.utils.common import (
    get_policy,
    get_default_policies,
    merge_exe_plan
)
from pprint import pprint
from llm_sanitation.standard_log.logging_setup import LogUtil, LogType, LogLevel


class Planner:
    """
    A class to represent the planning process for executing business and AI skills
    based on the policies defined in the use case manifest.

    Attributes
    ----------
    scanner_default : dict
        A dictionary containing default AI skills for various business skills.
    """

    def __init__(self):
        """
        Initializes the Planner with default AI skill configurations for various business skills.
        """
        self.scanner_default = scanner_default

    def reorder_plan(self, execution_plan):
        """
        Reorders the execution plan according to a predefined sequence of business skills.

        Parameters
        ----------
        execution_plan : dict
            A dictionary containing business skills as keys and associated AI skills as values.

        Returns
        -------
        dict
            The reordered execution plan with business skills in a specific predefined order.
        """
        b_skill_order = [
            "payload_validator",
            "file_bounding",
            "numeric_bounding",
            "numeric_sanitation",
            "text_bounding",
            "text_data_sanitation",
            "image_bounding",
            "image_data_sanitation",
        ]
        reordered_execution_plan = {}

        for b_skill in b_skill_order:
            if b_skill in execution_plan:
                reordered_execution_plan[b_skill] = execution_plan[b_skill]

        return reordered_execution_plan

    def get_plan(self, policies):

        actions = []
        no_actions = []
        ai_skills = []
        b_skills = []
        execution_plan = {}

        for policy in policies:
            policy_json = get_policy(policy)
            stmts = policy_json["Statement"]

            for stmt in stmts:
                actions = stmt["Action"]
                no_actions = stmt["NotAction"]

                skills = defaultdict(lambda: [])

                # Process Actions
                for action in actions:
                    b_skill, ai_skill = action.split(":")

                    if ai_skill == "*":
                        skills[b_skill].extend(self.scanner_default[b_skill])
                    else:
                        skills[b_skill].append(ai_skill)

                # Process NotActions
                for no_action in no_actions:
                    b_skill, ai_skill = no_action.split(":")
                    try:
                        if ai_skill == "*":
                            skills[b_skill].remove(self.scanner_default[b_skill])
                        else:
                            skills[b_skill].remove(ai_skill)
                    except ValueError:
                        pass

                # Add conditions to the execution plan
                skills = dict(skills)
                b_skills = skills.keys()
                for b_skill in b_skills:
                    ai_skills = skills[b_skill]
                    for ai_skill in ai_skills:
                        if b_skill not in execution_plan:
                            execution_plan[b_skill] = {}
                        execution_plan[b_skill][ai_skill] = stmt["Condition"].get(
                            ai_skill, {}
                        )

        # Print and return the reordered execution plan
        pprint(self.reorder_plan(execution_plan))
        return self.reorder_plan(execution_plan)


    def get_policies(self, data_policies, event="input"):
        plans = []
        for dtype in data_policies:
            plan = {}
            policies = data_policies[dtype]
            default_policy = get_default_policies("input", dtype)

            for policy in policies:
                plan["data"] = policy["data"]
                plan["policies"] = policy["policies"]
                plans.append(plan)
            plan["default_policy"] = default_policy
        return plans



    def get_exec_plan(self, data_policies):
        """
        Generates an execution plan for the given agent by analyzing the use case manifest policies.

        Parameters
        ----------
        usecase_mfst_nm : str
            The name of the use case manifest file.
        agent_nm : str, optional
            The name of the agent (default is "*", meaning all agents).

        Returns
        -------
        dict
            A dictionary representing the execution plan, where business skills are mapped to AI skills
            and their conditions defined in the policies.
        """

        exec_plans = []

        plans = self.get_policies(data_policies)

        LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Getting execution plan for INPUT Policies")

        for plan in plans:
            plan_item = {}
            policies = []

            policies.extend(plan["policies"])
            policies.extend(plan["default_policy"])

            exec_plan = self.get_plan(policies)

            plan_item["data"] = plan["data"]
            plan_item["exec_plan"] = exec_plan

            exec_plans.append(plan_item)

        return exec_plans
