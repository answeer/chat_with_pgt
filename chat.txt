import os
import traceback
from llm_sanitation.utils.callback import Callback
from llm_sanitation.utils.checks import Checks
from llm_sanitation.utils.error_codes import ERROR_CODE_DICT
from llm_sanitation.logging.logging_setup import LogUtil, LogType, LogLevel

class Action:
    DEFAULT_SCANNERS = {
        "file_bounding": {"FormatCheck": {'format_list': ['jpg', 'png', 'jpeg', 'pdf']}},
        "image_bounding": {
            "ImageBlurCheck": {'score_thresh': 0.6},
            "ImageDimCheck": {'img_dim_thresh': (1024, 1024)}
        },
        "text_bounding": {
            "HarmfulString": {"case_sensitive": False},
            "ProfanityCheck": {},
            "PiiDetector": {'sanitize': True},
            "RemoveUnicode": {"sanitize": True},
            "Secrets": {'sanitize': True}
        },
        "structured_bounding": {
            "JsonValidator": {}
        }
    }

    def __init__(self, **kwargs):
        LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Running Initialized")
        self.response = Callback(**kwargs)
        self.check = Checks(self.response)
        self.kwargs = kwargs
        self.combined_result = []
        self.nstp_result = []

    def determine_task_group(self, data):
        """Determines the task group based on file type or data format."""
        if isinstance(data, str) and os.path.isfile(data):
            ext = os.path.splitext(data)[1].lower()
            if ext in [".jpg", ".jpeg", ".png"]:
                return "image_bounding"
            elif ext in [".json"]:
                return "structured_bounding"
            elif ext in [".txt", ".csv", ".md"]:
                return "text_bounding"
            elif ext in [".pdf", ".docx"]:
                return "file_bounding"
        return "text_bounding"

    def run_scanner(self, data, scanner_nm, param, **kwargs):
        """Dynamically imports and runs the specified scanner with provided parameters."""
        try:
            scanners = __import__("llm_sanitation.scanners", fromlist=[scanner_nm])
            scanner = getattr(scanners, scanner_nm)
            scanner_obj = scanner(**param)
            result = scanner_obj.validate(data, **kwargs)
            self.combined_result.append(result)
            self.nstp_result.append(result.get("NSTP"))
            return result
        except (ImportError, AttributeError) as e:
            error_code = "FRDIOS9000"
            error_message = ERROR_CODE_DICT[error_code].format(str(e))
            self.response.form_response(error_code, error_message)
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Running ended with error", jid=self.kwargs['job_id'], error=error_message)
            return None

    def run_action(self, execution_plan, data, save_path):
        """Executes the scanning process based on the provided execution plan and scanner type."""
        try:
            job_id = self.kwargs['job_id']
            task_group = self.determine_task_group(data)
            default_scanners = self.DEFAULT_SCANNERS.get(task_group, {})

            # Merge default scanners with the execution plan
            execution_plan = {**default_scanners, **execution_plan}

            # Run pre-check based on task group
            if task_group == "file_bounding":
                self.check.file_exists(data)
            elif task_group == "image_bounding":
                self.check.check_image(data)
            elif task_group == "text_bounding":
                self.check.check_text(data)
            elif task_group == "structured_bounding":
                self.check.check_structure(data)
            else:
                error_code = "FRDIOS0006"
                error_message = ERROR_CODE_DICT[error_code].format(str(task_group))
                LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Running ended with error", jid=job_id, error=error_message)
                return None, error_code, error_message
            
            if self.response.status == "failed":
                error_code = self.response.error_code
                error_message = self.response.error_message
                LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Running ended with error", jid=job_id, error=error_message)
                return None, error_code, error_message
            
            # Run each scanner
            for scanner_nm, param in execution_plan.items():
                result = self.run_scanner(data, scanner_nm, param, **kwargs)
                data = data if result["sanitized_data"] is None else result["sanitized_data"]
                
                if self.response.status == "failed":
                    error_code = self.response.error_code
                    error_message = self.response.error_message
                    LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Running ended with error", jid=job_id, error=error_message)
                    return None, error_code, error_message

            return self.combined_result, "", ""

        except Exception as e:
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Running ended with error", jid=job_id, error=str(e))
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, traceback.format_exc())
            error_code = "FRDIOS9000"
            error_message = ERROR_CODE_DICT[error_code].format(str(e))

        finally:
            if save_path:
                response_json_path = os.path.join(save_path, task_group + "_response.json")
                self.response.save_results(combined_result=self.combined_result)
                self.response.return_response(response_json_path, error_code, error_message)

if __name__ == "__main__":
    # Example main function
    # Additional code for loading payload and executing `run_action` based on task group.
payload = {
        "job_params": {
            "jobid": "JID-54ca58ba-c495-11ed-b20c-0a586e830578",
            "task_id": "TID-54ca58ba-c495-11ed-b20c-0a586e830578",
            "app_name": "synthesizer",
            "use_case": "aadhar_redact",
            "save_path": r"C:\path\to\save",
        },
        "service_params": {
            "callback_url": "http://callback.url",
            "job_object": {
                "io": "i",
                "policy_id": "policy_00001",
                "data": r"path/to/your/file.jpg",
                "execution_plan": {
                    "AdditionalScanner": {'param_key': 'param_value'}
                }
            }
        }
    }

    kwargs = {
        "job_id": payload["job_params"].get("jobid", "NA"),
        "task_id": payload["job_params"].get("task_id", "NA"),
        "use_case": payload["job_params"].get("use_case", "NA"),
        "io": payload["service_params"]["job_object"].get("io", "NA"),
        "policy_id": payload["service_params"]["job_object"].get("policy_id", "NA"),
        "data": payload["service_params"]["job_object"].get("data", ""),
    }

    action_obj = Action(**kwargs)
    result, error_code, error_message = action_obj.run_action(
        payload["service_params"]["job_object"]["execution_plan"],
        payload["service_params"]["job_object"]["data"],
        payload["job_params"]["save_path"]
    )
    print("Action completed", result)
