import os
import traceback
from guardrails.utils.callback import Callback
from guardrails.utils.checks import Checks
from guardrails.agent.utils.connectors import get_data
from guardrails.utils.error_codes import ERROR_CODE_DICT
from guardrails.standard_log.logging_setup import LogUtil, LogType, LogLevel

class Action:
    def __init__(
        self,
        **kwargs,
    ):
        LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Running Initialized")
        self.response = Callback(**kwargs)
        self.check = Checks(self.response)
        self.kwargs = kwargs
        self.combined_result = []
        self.nstp_result = []
        self.failed_response = []
        self.exec_plan_response_tmpl = {
            "data": [],
            "guardrails": [],
        }

    def determine_task_group(
        self,
    ):
        """Determines the task group based on the input data type."""

        return "validators"

    def run_scanner(self, data, scanner_nm, param, **kwargs):
        """Dynamically imports and runs the specified scanner with provided parameters."""

        scanners = __import__("guardrails.scanners", fromlist=[scanner_nm])
        scanner = getattr(scanners, scanner_nm)
        scanner_obj = scanner(**param)
        result = scanner_obj.validate(data, **self.kwargs)

        self.nstp_result.append(result.get("NSTP"))

        # collect error response
        if result.get("NSTP"):
            self.failed_response.append(str(result.get("response","")))

        return result

    def get_result(self):
        """Returns all combined results from the scanners."""
        return self.combined_result

    def get_nstp_result(self):
        """Returns NSTP results from each scanner."""
        return self.nstp_result

    def get_errorcode(self):
        error_code = ""
        error_message = ""

        if any(self.get_nstp_result()):
            err_code = "SWHIOSERR0020"
            error_code = err_code
            error_message = ERROR_CODE_DICT[err_code].format(self.failed_response)

        return error_code, error_message

    def run_action(self, execution_plans, payload, save_path="."):
        """Executes the scanning process based on the provided execution plan and scanner type."""

        error_code = ""
        error_message = ""
        job_id = self.kwargs["job_id"]
        task_group = self.determine_task_group()

        self.kwargs["task_group"] = task_group

        for exec_plan in execution_plans:
            exec_plan_response = self.process_execution_plan(exec_plan, payload, job_id)
            if self.response.status == "failed":
                return None, self.response.error_code, self.response.error_message
            self.combined_result.append(exec_plan_response)

        # get error codes
        error_code, error_message = self.get_errorcode()

        # Save response
        if save_path:
            response_json_path = os.path.join(
                save_path, task_group + "_response.json"
            )
            self.response.save_results(combined_result=self.combined_result)
            self.response.return_response(
                response_json_path, error_code, error_message
            )

        print(self.combined_result)
        return self.combined_result, error_code, error_message

    def process_execution_plan(self, exec_plan, payload, job_id):
        exec_plan_response = self.exec_plan_response_tmpl.copy()
        execution_plan = exec_plan["exec_plan"]
        data_paths = exec_plan["data"]
        exec_plan_response["data"].extend(data_paths)

        for data_path in data_paths:
            data = get_data(data_path, payload)
            self.check.check_payload(data)
            if self.has_validation_failed():
                return exec_plan_response

            exec_plan_response = self.process_scanners(
                data, execution_plan, exec_plan_response, job_id
            )
            if self.response.status == "failed":
                break

        return exec_plan_response

    def process_scanners(self, data, execution_plan, exec_plan_response, job_id):

        for _, plan in execution_plan.items():
            for scanner_nm, param in plan.items():
                result = self.run_scanner(data, scanner_nm, param, **self.kwargs)
                exec_plan_response["guardrails"].append(result)
                data = result["sanitized_data"] or data
                if self.has_operation_failed():
                    self.log_error(job_id, self.response.error_message)
                    break
        return exec_plan_response

    def has_validation_failed(self):

        return self.response.status == "failed"

    def has_operation_failed(self):
        return self.response.status == "failed"

    def log_error(self, job_id, error_message):
        LogUtil.log(
            LogType.ERROR,
            LogLevel.ERROR,
            "Running ended with error",
            jid=job_id,
            error=error_message,
        )

if __name__ == "__main__":
    payload = {
        "job_params": {
            "jobid": "JID-54ca58ba-c495-11ed-b20c-0a586e830578",
            "task_id": "TID-54ca58ba-c495-11ed-b20c-0a586e830578",
            "app_name": "synthesizer",
            "use_case": "aadhar_redact",
        },
        "service_params": {
            "callback_url": "http://service-swoosh-orchestrator.swoosh-dev.svc.cluster.local:8889/api/v1/callback",
            "job_object": {
                "io": "i",
                "policy_id": "policy_00001",
                "execution_plan": {},
                "data": {
                    "clientData": {
                        "clientRefNumber": "AP39HN7997",
                        "country": "IN",
                        "appName": "seige_v3",
                        "alpha numeric": "aaFF5",
                        "JID": "JID-123aaad3-aa44-2233-823a-1234ffaa5567",
                        "doc-id": "123aaad3-aa44-2323-23aa-1234ffaa5567",
                    }
                },
            },
        },
    }

    exec_plans = [
        {
            "data": ["*"],
            "exec_plan": {
                "payload_validator": {
                    "JsonValidator": {
                        "mandate_keys": {
                            "clientData.appName": ["seige_v3", "RTOB_IN_AADHAR", "SSO"],
                            "clientData.country": ["IN"],
                            "clientData.consumerid": [],
                            "clientData.clientRefNumber": [],
                        }
                    }
                }
            },
        },
        {
            "data": ["data.sometext", "data.sometext.another_text"],
            "exec_plan": {
                "text_bounding": {
                    "TokonLimit": {"token_limit": 100, "token_method": "nltk"},
                    "ProfanityCheck": {},
                    "ExecutableScript": {},
                    "HarmfulString": {"case_sensitive": False},
                }
            },
        },
    ]

    kwargs = {
        "job_id": "NA",
        "task_id": "NA",
        "use_case": "use_case",
        "io": "io",
        "policy_id": "policy_id",
        "job_id": "jobid",
        "task_id": "task_id",
        "use_case": "use_case",
        "io": "io",
        "policy_id": "policy_id",
        "event": "event",
    }

    action_obj = Action(**kwargs)
    action_obj.run_action(exec_plans, payload)
