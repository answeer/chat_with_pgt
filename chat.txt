import cv2
import numpy as np
import os
from tqdm import tqdm
from skimage.metrics import structural_similarity as compare_ssim

def preprocess_image(image):
    """Preprocess the image to enhance structural elements."""
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) if len(image.shape) == 3 else image
    binary = cv2.adaptiveThreshold(
        gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 15, 10
    )
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    processed = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)
    return processed

def align_images(template, target):
    """Align the target image to the template using affine or homography transformation."""
    template_proc = preprocess_image(template)
    target_proc = preprocess_image(target)

    # Detect ORB keypoints and descriptors
    orb = cv2.ORB_create(5000)
    kp1, desc1 = orb.detectAndCompute(template_proc, None)
    kp2, desc2 = orb.detectAndCompute(target_proc, None)

    # Match descriptors using BFMatcher
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(desc1, desc2)
    matches = sorted(matches, key=lambda x: x.distance)

    # Extract matched keypoints
    src_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)

    if len(matches) >= 3:
        # Affine transformation requires at least 3 points
        matrix = cv2.estimateAffinePartial2D(dst_pts, src_pts, method=cv2.RANSAC)[0]
        aligned = cv2.warpAffine(target, matrix, (template.shape[1], template.shape[0]))
    elif len(matches) >= 4:
        # Fall back to homography transformation if 4 or more matches are found
        matrix, _ = cv2.findHomography(dst_pts, src_pts, cv2.RANSAC, 5.0)
        aligned = cv2.warpPerspective(target, matrix, (template.shape[1], template.shape[0]))
    else:
        raise ValueError("Not enough matches found for alignment.")

    return aligned, matrix

def overlay_images(template, aligned, alpha=0.5):
    """Overlay the aligned image onto the template."""
    if len(template.shape) == 2:
        template = cv2.cvtColor(template, cv2.COLOR_GRAY2BGR)
    if len(aligned.shape) == 2:
        aligned = cv2.cvtColor(aligned, cv2.COLOR_GRAY2BGR)
    overlay = cv2.addWeighted(template, alpha, aligned, 1 - alpha, 0)
    return overlay

def evaluate_alignment(template, aligned):
    """Evaluate the alignment using multiple metrics."""
    # Ensure images are the same size
    aligned = cv2.resize(aligned, (template.shape[1], template.shape[0]))

    # Compute MSE
    mse = np.mean((template.astype("float") - aligned.astype("float")) ** 2)

    # Compute SSIM
    ssim, _ = compare_ssim(template, aligned, full=True)

    # Compute corner alignment accuracy
    corners_template = np.array([[0, 0], [template.shape[1], 0], 
                                  [template.shape[1], template.shape[0]], [0, template.shape[0]]], dtype=np.float32)
    corners_aligned = corners_template  # Assumes alignment is applied to the entire image
    corner_error = np.mean(np.linalg.norm(corners_template - corners_aligned, axis=1))

    return {"MSE": mse, "SSIM": ssim, "Corner Error": corner_error}

def get_image_paths_from_folder(folder_path):
    """Retrieve all image file paths from the specified folder."""
    valid_extensions = {".png", ".jpg", ".jpeg", ".bmp", ".tiff"}
    image_paths = [
        os.path.join(folder_path, fname)
        for fname in os.listdir(folder_path)
        if os.path.splitext(fname.lower())[1] in valid_extensions
    ]
    return image_paths

def process_transfer_slips(template_path, filled_slip_folder, output_dir):
    """Align all filled slips with the template, save results, and evaluate accuracy."""
    template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
    filled_slip_paths = get_image_paths_from_folder(filled_slip_folder)
    os.makedirs(output_dir, exist_ok=True)

    results = []
    for idx, slip_path in enumerate(tqdm(filled_slip_paths, desc="Processing Transfer Slips")):
        target = cv2.imread(slip_path, cv2.IMREAD_GRAYSCALE)

        try:
            aligned, _ = align_images(template, target)
            overlay = overlay_images(template, aligned)

            aligned_path = os.path.join(output_dir, f"aligned_{idx + 1}.png")
            overlay_path = os.path.join(output_dir, f"overlay_{idx + 1}.png")
            cv2.imwrite(aligned_path, aligned)
            cv2.imwrite(overlay_path, overlay)

            metrics = evaluate_alignment(template, aligned)
            metrics["Image"] = os.path.basename(slip_path)
            results.append(metrics)

            print(f"Processed {slip_path}: Aligned saved to {aligned_path}, Overlay saved to {overlay_path}")
        except ValueError as e:
            print(f"Skipping {slip_path}: {str(e)}")

    return results

def save_evaluation_results(results, output_dir):
    """Save the evaluation results to a CSV file."""
    import csv
    csv_path = os.path.join(output_dir, "evaluation_results.csv")
    with open(csv_path, mode="w", newline="") as file:
        writer = csv.DictWriter(file, fieldnames=["Image", "MSE", "SSIM", "Corner Error"])
        writer.writeheader()
        writer.writerows(results)
    print(f"Evaluation results saved to {csv_path}")

# Example Usage
if __name__ == "__main__":
    template_path = "path_to_template_image.png"  # Path to the blank transfer slip
    filled_slip_folder = "path_to_filled_slips_folder"  # Folder containing all filled slips
    output_dir = "output_directory"  # Directory to save results

    results = process_transfer_slips(template_path, filled_slip_folder, output_dir)
    save_evaluation_results(results, output_dir)
