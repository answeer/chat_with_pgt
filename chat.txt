from llm_sanitation.scanners.scanner_base import Scanner
from llm_sanitation.utils.models import *
import json
import numpy as np
import re
from llm_sanitation.logging.logging_setup import LogUtil, LogType, LogLevel


class JsonValidator(Scanner):

    def __init__(self, **kwargs):
        mandate_checks = kwargs["mandate_keys"]
        super().__init__("json_validator",  1, mandate_checks= mandate_checks)

    def get_value(self, payload, keys):
        keys = keys.split(".")
        value = payload
        for key in keys:
            if isinstance(value, dict):
                value = value.get(key)
            else:
                return None
        return value

    def check_mandate_keys(self, payload):
        self.mandate_keys = self._kwargs["mandate_checks"].keys()

        predict = []
        score = []
        try:
            for mandate_key in self.mandate_keys:
                mandate_pattern = self._kwargs["mandate_checks"].get(mandate_key, [])
                pattern = re.compile(mandate_pattern)
                
                value = self.get_value(payload, mandate_key)

                if value is None:
                    score.append(0)
                    predict.append("Key `{}` not found".format(mandate_key))

                elif re.match(pattern,value):
                    score.append(1)
                else:
                    score.append(0)
                    predict.append("For Key `{}` value {} is not in the correct pattern.".format(mandate_key, value))

        except Exception as e:
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, e)
            predict.append("Error occured: {}".format(e))
            score.append(0)
            # if value is None:
            #     score.append(0)
            #     predict.append("Key `{}` not found".format(mandate_key))

            # elif mandate_value and value not in mandate_value:
            #     score.append(0)
            #     predict.append("For Key `{}` value {} is not in the given list of possible values".format(mandate_key, value))
            # else:
            #     score.append(1)
            #     # predict.append("For Key `{}` value {} check passed".format(mandate_key, value))


        return predict, np.mean(score)

    # def check_mandate_keys(self, parsed_payload):
    #     """Check the necessary key value pairs."""
    #     predict = []
    #     score = []
    #     mandate_keys = self.mandate_keys

    #     for mandate_key in mandate_keys:
    #         key, value = next(iter(mandate_key.items()))
    #         if key not in self.mandate_keys:
    #             predict.append(f"Missing the mandate key of {key}")
    #             score = 0
    #         if value not in mandate_key["possible_val"]:
    #             predict.append(
    #                 f"For {key}, the set value:{value} is not in the possible value list, please check the paylaod and recheck."
    #             )
    #             score.append(0)
    #     if len(predict) == 0:
    #         predict = "This payload is Valid."
    #         score = 1
    #     return predict, score

    def check_json_format(self, payload):
        """Validates that a value is parseable as valid JSON."""
        stringified = payload
        parsed_payload, error = (None, None)
        try:
            if not isinstance(payload, str):
                stringified = json.dumps(payload)

            parsed_payload = json.loads(stringified)
        except json.decoder.JSONDecodeError as json_error:
            error = json_error
        except TypeError as type_error:
            error = type_error
        return parsed_payload, error

    def predict(self, payload):
        parsed_payload, error = self.check_json_format(payload)
        if error is not None:
            score = 0
            predict = error
            return predict, score
        else:
            predict, score = self.check_mandate_keys(parsed_payload)
        return predict, score

    def format_response(self):
        self.response["prediction"]["json_validator"] = self.pred[0]
        self.response["score"] = self.pred[1]
