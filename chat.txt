if self.async_mode:  # If async mode is enabled, use ThreadPoolExecutor
    with ThreadPoolExecutor(max_workers=8) as executor:
        batch_size = 10  # 控制每次提交任务的数量
        futures = []
        for _ in range(50):
            for scanner_nm, param in execution_plan.items():
                future = executor.submit(self.run_scanner, data, scanner_nm, param, **self.kwargs)
                futures.append(future)
                
                if len(futures) >= batch_size:  # 当批次达到指定大小时
                    for future in as_completed(futures):
                        result = future.result()  # 等待当前批次任务的结果
                        if result is None and self.response.status == "failed":
                            error_code = self.response.error_code
                            error_message = self.response.error_message
                            LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Running ended with error", jid=job_id, error=error_message)
                            return None, error_code, error_message
                    futures.clear()  # 清空已处理的future对象

        # 如果剩下有未处理的任务
        for future in as_completed(futures):
            result = future.result()
            if result is None and self.response.status == "failed":
                error_code = self.response.error_code
                error_message = self.response.error_message
                LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Running ended with error", jid=job_id, error=error_message)
                return None, error_code, error_message
