import torch
from torchvision import models, datasets, transforms

# 加载预训练的浮点模型
float_model = models.resnet18(pretrained=True)
float_model.eval()

# 准备训练数据
transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])

train_dataset = datasets.ImageFolder(root='path_to_train_data', transform=transform)
train_dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=32, shuffle=True)

# 使用部分训练数据进行校准
calibration_data = []
for i, (inputs, _) in enumerate(train_dataloader):
    calibration_data.append(inputs)
    if i >= 10:  # 使用前10个batch的数据进行校准
        break

# 准备模型量化
float_model.fuse_model()  # 对ResNet模型进行融合操作
float_model.qconfig = torch.quantization.get_default_qconfig('fbgemm')
torch.quantization.prepare(float_model, inplace=True)

# 校准模型
float_model.eval()
with torch.no_grad():
    for input in calibration_data:
        float_model(input)

# 量化模型
torch.quantization.convert(float_model, inplace=True)

# 保存量化后的模型
torch.save(float_model.state_dict(), 'quantized_model.pth')

# 检查权重数据类型
for name, param in float_model.named_parameters():
    print(f"{name}: {param.dtype}")

# 加载量化后的模型
quantized_model = models.resnet18()  # 使用相同的模型结构
quantized_model.fuse_model()  # 对ResNet模型进行融合操作
quantized_model.qconfig = torch.quantization.get_default_qconfig('fbgemm')
torch.quantization.prepare(quantized_model, inplace=True)
torch.quantization.convert(quantized_model, inplace=True)
quantized_model.load_state_dict(torch.load('quantized_model.pth'))

# 检查加载后权重数据类型
for name, param in quantized_model.named_parameters():
    print(f"{name}: {param.dtype}")
