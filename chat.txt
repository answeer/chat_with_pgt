import cv2

# 读取图像
image = cv2.imread('id_card_image.jpg')

# 当前模型的 bounding box 坐标 (x_min, y_min, x_max, y_max)
# 假设模型输出了卡号的完整 bounding box
x_min, y_min, x_max, y_max = (100, 50, 400, 100)  # 替换为实际模型给出的坐标

# 1. 提取卡号的图像区域
card_number_region = image[y_min:y_max, x_min:x_max]

# 2. 计算前8位数字的区域
# 假设卡号是12位数字，按比例计算前8位数字的宽度
total_width = x_max - x_min
x_max_8_digits = x_min + int(8/12 * total_width)

# 3. 使用 OpenCV 画出前8位数字的 bounding box
new_bounding_box = (x_min, y_min, x_max_8_digits, y_max)
cv2.rectangle(image, (x_min, y_min), (x_max_8_digits, y_max), (0, 255, 0), 2)

# 4. 处理卡号区域，使用阈值化和轮廓检测进一步分割数字
gray = cv2.cvtColor(card_number_region, cv2.COLOR_BGR2GRAY)
_, thresh = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY_INV)

# 检测轮廓
contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# 过滤并按 x 坐标排序轮廓
contours = sorted(contours, key=lambda c: cv2.boundingRect(c)[0])

# 提取前8个轮廓的 bounding box
for i in range(min(8, len(contours))):
    x, y, w, h = cv2.boundingRect(contours[i])
    cv2.rectangle(card_number_region, (x, y), (x + w, y + h), (255, 0, 0), 2)

# 显示前8位数字的轮廓
cv2.imshow('8 Digits Bounding Box', image)
cv2.imshow('8 Digits Details', card_number_region)
cv2.waitKey(0)
cv2.destroyAllWindows()
