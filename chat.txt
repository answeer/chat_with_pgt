import cv2
import os
import glob
import numpy as np
import itertools
import matplotlib.pyplot as plt
from skimage.metrics import structural_similarity as ssim
from tqdm import tqdm

# === 图像路径加载函数 ===
def load_image_paths(root_dir, extensions=('*.tiff', '*.png', '*.jpg')):
    image_paths = []
    for ext in extensions:
        image_paths.extend(glob.glob(os.path.join(root_dir, ext)))
    return image_paths

# === 保存对齐效果函数 ===
def save_overlay_image(template, aligned_image, output_path, alpha=0.5):
    # 将对齐图片与模板叠加
    overlay = cv2.addWeighted(template, alpha, aligned_image, 1 - alpha, 0)
    cv2.imwrite(output_path, overlay)

# === 算法封装 ===
def alignment_algorithm_1(template, target):
    orb = cv2.ORB_create()
    kp1, desc1 = orb.detectAndCompute(template, None)
    kp2, desc2 = orb.detectAndCompute(target, None)
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(desc1, desc2)
    src_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)
    matrix, _ = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
    aligned = cv2.warpPerspective(target, matrix, (template.shape[1], template.shape[0]))
    return aligned

def alignment_algorithm_2(template, target):
    warp_matrix = np.eye(3, 3, dtype=np.float32)
    _, warp_matrix = cv2.findTransformECC(template, target, warp_matrix, cv2.MOTION_HOMOGRAPHY)
    aligned = cv2.warpPerspective(target, warp_matrix, (template.shape[1], template.shape[0]))
    return aligned

def alignment_algorithm_3(template, target):
    akaze = cv2.AKAZE_create()
    kp1, desc1 = akaze.detectAndCompute(template, None)
    kp2, desc2 = akaze.detectAndCompute(target, None)
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(desc1, desc2)
    src_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)
    matrix, _ = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
    aligned = cv2.warpPerspective(target, matrix, (template.shape[1], template.shape[0]))
    return aligned

# === 评估函数 ===
def evaluate_metrics(template, aligned_image):
    ssim_score = ssim(template, aligned_image, full=False)
    _, binary_template = cv2.threshold(template, 128, 255, cv2.THRESH_BINARY)
    _, binary_aligned = cv2.threshold(aligned_image, 128, 255, cv2.THRESH_BINARY)
    intersection = np.logical_and(binary_template, binary_aligned).sum()
    union = np.logical_or(binary_template, binary_aligned).sum()
    iou_score = intersection / union
    diff = cv2.absdiff(template, aligned_image)
    mean_pixel_error = np.mean(diff)
    return ssim_score, iou_score, mean_pixel_error

# === 主测试函数 ===
def batch_evaluation(root_dir, algorithms):
    image_paths = load_image_paths(root_dir)
    results = {f"Algorithm {i+1}": [] for i in range(len(algorithms))}
    pairs = list(itertools.combinations(image_paths, 2))
    
    for algo_idx, algorithm in enumerate(algorithms):
        algo_name = f"Algorithm {algo_idx+1}"
        output_dir = f"./results/{algo_name}"
        os.makedirs(output_dir, exist_ok=True)
        print(f"Running {algo_name}...")
        
        for template_path, target_path in tqdm(pairs, desc=f"Processing {algo_name}"):
            template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
            target = cv2.imread(target_path, cv2.IMREAD_GRAYSCALE)
            aligned_image = algorithm(template, target)
            
            # 评估指标
            metrics = evaluate_metrics(template, aligned_image)
            results[algo_name].append(metrics)
            
            # 保存叠加效果
            overlay_path = os.path.join(output_dir, f"overlay_{os.path.basename(template_path)}_{os.path.basename(target_path)}.png")
            save_overlay_image(template, aligned_image, overlay_path)

            # 打印日志
            ssim_score, iou_score, mean_error = metrics
            print(f"Template: {os.path.basename(template_path)}, Target: {os.path.basename(target_path)}")
            print(f"SSIM: {ssim_score:.4f}, IoU: {iou_score:.4f}, Mean Pixel Error: {mean_error:.2f}")
    
    return results

# === 可视化函数 ===
def visualize_results(summary):
    algorithms = list(summary.keys())
    metrics = ['SSIM', 'IoU', 'Mean Pixel Error']
    
    avg_values = [summary[algo]["Average"] for algo in algorithms]
    avg_values = np.array(avg_values).T  # 转置以便绘图
    
    plt.figure(figsize=(12, 6))
    for i, metric in enumerate(metrics):
        plt.subplot(1, 3, i+1)
        plt.bar(algorithms, avg_values[i], color=['blue', 'orange', 'green'])
        plt.title(metric)
        plt.ylabel('Score' if i < 2 else 'Error')
        for j, value in enumerate(avg_values[i]):
            plt.text(j, value + 0.01, f"{value:.2f}", ha='center')
    plt.tight_layout()
    plt.show()

# === 运行测试 ===
root_dir = "path/to/images"  # 替换为图片根目录
algorithms = [alignment_algorithm_1, alignment_algorithm_2, alignment_algorithm_3]
results = batch_evaluation(root_dir, algorithms)

# 计算平均值和方差
summary = {}
for algo_name, values in results.items():
    metrics = np.array(values)
    avg_metrics = np.mean(metrics, axis=0)
    var_metrics = np.var(metrics, axis=0)
    summary[algo_name] = {
        "Average": avg_metrics,
        "Variance": var_metrics
    }

visualize_results(summary)
