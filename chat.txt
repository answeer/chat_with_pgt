


def create_bronze(spark, bronze_table_name):
    spark.sql(
        f"""
    CREATE TABLE IF NOT EXISTS {bronze_table_name} (
    input_file STRING,
    modificationTime TIMESTAMP,
    length BIGINT,
    content BINARY,
    _datetime TIMESTAMP,
    file_hash STRING
    ) TBLPROPERTIES (delta.enableChangeDataFeed = true)
            """
    )


def create_silver(spark, silver_table_name):
    spark.sql(
        f"""
    CREATE TABLE IF NOT EXISTS {silver_table_name} (
    input_file STRING,
    page_nr STRING,
    page_content STRING,
    document_name STRING,
    _datetime TIMESTAMP
    ) TBLPROPERTIES (delta.enableChangeDataFeed = true)
            """
    )


def create_gold(spark, gold_table_name):
    spark.sql(
        f"""
    CREATE TABLE IF NOT EXISTS {gold_table_name} (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    input_file STRING,
    page_nr STRING,
    document_name STRING,
    content_chunk STRING,
    _datetime TIMESTAMP,
    page_content STRING
    ) TBLPROPERTIES (delta.enableChangeDataFeed = true)
            """
    )



from RAGaaS.utils.get_cluster_params import (
    embedding_model,
    chunking_strategy,
    chunk_overlap,
    max_tokens,
)
import pyspark.sql.functions as func
from RAGaaS.data_pipeline.chunking.recursive_char_split import recursive_character_split
from RAGaaS.utils.template import gold_table_name
from RAGaaS.data_pipeline.medallian_tables.create_medallian_table import (
    create_gold
)

CHUNK_STRATEGY_MAP = {"recursive_character_split": recursive_character_split}


def create(spark, df_silver):

    create_gold(spark, gold_table_name)

    chunk_function = CHUNK_STRATEGY_MAP.get(chunking_strategy)

    if chunking_strategy == "recursive_character_split":
        args = {
            "col": func.col("page_content"),
            "chunk_size": max_tokens,
            "chunk_overlap": chunk_overlap,
            "explode": True,
        }

    else:
        raise ValueError(f"Unsupported chunking strategy: {chunking_strategy}")

    df_gold = (
        df_silver.withColumn("page_chunks", chunk_function(**args))
        .withColumn("content_chunk", func.col("page_chunks.content_chunk"))
        .withColumn("_datetime", func.current_timestamp())
        .drop("page_chunks")
    )

    df_gold.write.mode("overwrite").saveAsTable(gold_table_name)
