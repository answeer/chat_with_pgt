import os
import copy
from concurrent.futures import ThreadPoolExecutor, as_completed
from guardrails.utils import checks
from guardrails.utils.connectors.connectors import get_data
from guardrails.utils.error_codes import ERROR_CODE_DICT
from guardrails.utils.exception import GuardrailsError
from guardrails.standard_log.logging_setup import LogUtil, LogType, LogLevel
from guardrails.utils.time_keeper import WatchTime
from pprint import pprint
import json
import threading

watch_obj = WatchTime()

class Action:
    def __init__(
        self,
        **kwargs,
    ):
        LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Action Initialized")
        self.kwargs = kwargs
        self.async_mode = True
        self.combined_result = []
        self.nstp_result = []
        self.failed_response = []
        self.final_response = {
            "error_code": "",
            "error_messages": "",
            "result":[]
            }
        self.exec_plan_response_tmpl = {
            "data": [],
            "guardrails": [],
        }
        # Thread-safe locks for shared resources
        self.nstp_lock = threading.Lock()
        self.failed_lock = threading.Lock()

    def check_task_group(self,data):
        if self.kwargs['task_group'] == "file_bounding":
            checks.file_exists(data)
        elif self.kwargs['task_group'] == "image_bounding":
            checks.file_exists(data)
            checks.check_image(data)
        elif self.kwargs['task_group'] == "text_bounding":
            checks.check_text(data)
        elif self.kwargs['task_group'] == "numeric_bounding":
            checks.check_numeric(data)
        else:
            raise GuardrailsError("SWHIOSERR0006",str(self.kwargs['task_group']))

    def determine_task_group(self, exec_plan):
        execution_plan = exec_plan['exec_plan']
        task_group_key = execution_plan.keys()
        task_group = next(iter(task_group_key))
        return task_group

    def run_scanner(self, data, scanner_nm, param, **kwargs):
        """Dynamically imports and runs the specified scanner with provided parameters."""
        scanners = __import__("guardrails.scanners", fromlist=[scanner_nm])
        if not hasattr(scanners, scanner_nm):
            raise GuardrailsError("SWHIOSERR0041",scanner_nm)
        scanner = getattr(scanners, scanner_nm)
        scanner_obj = scanner(**param)
        result = scanner_obj.validate(data, **self.kwargs)
        if not isinstance(result, dict) or 'NSTP' not in result:
            raise GuardrailsError("SWHIOSERR0042",scanner_nm)
        # Thread-safe updates
        with self.nstp_lock:
            self.nstp_result.append(result.get("NSTP"))
        if result.get("NSTP"):
            with self.failed_lock:
                self.failed_response.append(str(result.get("response","")))
        return result

    def get_result(self):
        return self.combined_result

    def get_nstp_result(self):
        return self.nstp_result

    def get_errorcode(self):
        error_code = ""
        error_message = ""
        if any(self.get_nstp_result()):
            err_code = "SWHIOSERR0040"
            error_code = err_code
            error_message = ERROR_CODE_DICT[err_code].format(", ".join(self.failed_response))
        return error_code, error_message

    def run_action(self, request, save_path="."):
        try:
            LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Running action started")
            response = copy.deepcopy(self.final_response)
            error_code = ""
            error_message = ""
            job_id = self.kwargs["job_id"]
            execution_plans = request.get('service_params',{}).get('job_object',{}).get('plan',{})
            payload = request.get('service_params',{}).get('job_object',{}).get('payload',{})
            if execution_plans is None:
                raise GuardrailsError("SWHIOSERR0044")
            if payload is None:
                raise GuardrailsError("SWHIOSERR0045")
            for ix, exec_plan in enumerate(execution_plans):
                LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, f"Stated Executing plan {ix+1}/{len(execution_plans)}")
                self.kwargs['task_group'] = self.determine_task_group(exec_plan)
                LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, f"Running task {self.kwargs['task_group']}")
                exec_plan_response = copy.deepcopy(self.exec_plan_response_tmpl)
                execution_plan = exec_plan["exec_plan"].get(self.kwargs['task_group'],{})
                data_paths = exec_plan["data"]
                for data_path in data_paths:
                    data_items = get_data(data_path, payload)
                    if not data_items:
                        raise GuardrailsError("SWHIOSERR0043", data_path)
                    if not isinstance(data_items, list):
                        data_items = [data_items]
                    for data in data_items:
                        self.check_task_group(data)
                        exec_plan_response["data"].append(data)
                        scanner_results = self.process_scanners(data, execution_plan)
                        exec_plan_response['guardrails'].append(scanner_results)
                self.combined_result.append(exec_plan_response)
                LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, f"Completed Executing plan {ix+1}/{len(execution_plans)}")
            timelog_path = os.path.join(save_path, "time_log.json")
            watch_obj.save_logs(timelog_path)
            LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, f"Timelogs Saved in path : {timelog_path}")
            error_code, error_message = self.get_errorcode()
            response["error_code"] = error_code
            response["error_messages"] = error_message  # Corrected key
            response["result"] = self.combined_result
            stp_path = os.path.join(save_path, ".stp")
            with open(stp_path, "w") as file:
                file.write("")
            LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, f".stp Saved in path : {stp_path}")
            LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Running action completed")
            return response, error_code, error_message
        except GuardrailsError as e:
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Guardrails custom exception encountered", jid=job_id, error=str(e.message))
            response["error_code"] = e.error_code
            response["error_messages"] = e.message  # Corrected key
            response["result"] = []
            return None, e.error_code, e.message
        except Exception as e:
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, "Technical error Occurred", jid=job_id, error=str(e))
            error_code = "SWHIOSERR9000"
            error_message = ERROR_CODE_DICT[error_code].format(str(e))
            response["error_code"] = error_code
            response["error_messages"] = error_message  # Corrected key
            response["result"] = []
            return None, error_code, error_message
        finally:
            response_json_path = os.path.join(save_path, "scanner_result.json")
            with open(response_json_path, "w") as file:
                json.dump(response, file, indent=4)
            LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, f"Response Saved in path : {response_json_path}")

    def process_scanners(self, data, execution_plan):
        exec_plan = copy.deepcopy(execution_plan)
        results = []
        if "EncryptionDetector" in exec_plan:
            result = self.run_scanner(data, "EncryptionDetector", exec_plan['EncryptionDetector'], **self.kwargs)
            results.append(result)
            del exec_plan["EncryptionDetector"]
            if result["response"]["is_protected"]:
                LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, f"File is encrypted, skipping scanners: {list(exec_plan.keys())}")
                return results
        # Run remaining scanners in parallel
        with ThreadPoolExecutor() as executor:
            futures = {executor.submit(self.run_scanner, data, scanner_nm, param): (scanner_nm, param) for scanner_nm, param in exec_plan.items()}
            for future in as_completed(futures):
                try:
                    result = future.result()
                    results.append(result)
                except Exception as e:
                    LogUtil.log(LogType.ERROR, LogLevel.ERROR, f"Scanner {futures[future][0]} failed: {str(e)}")
        return results

if __name__ == "__main__":
    # ... [The sample request and test code remain unchanged] ...
