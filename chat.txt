import cv2
import os
import glob
import numpy as np
import itertools
import matplotlib.pyplot as plt
from skimage.metrics import structural_similarity as ssim

# === 图像路径加载函数 ===
def load_image_paths(root_dir, extensions=('*.tiff', '*.png', '*.jpg')):
    image_paths = []
    for ext in extensions:
        image_paths.extend(glob.glob(os.path.join(root_dir, ext)))
    return image_paths

# === 算法封装（参考前述示例） ===
def alignment_algorithm_1(template, target):
    orb = cv2.ORB_create()
    kp1, desc1 = orb.detectAndCompute(template, None)
    kp2, desc2 = orb.detectAndCompute(target, None)
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(desc1, desc2)
    src_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)
    matrix, _ = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
    aligned = cv2.warpPerspective(target, matrix, (template.shape[1], template.shape[0]))
    return aligned

def alignment_algorithm_2(template, target):
    warp_matrix = np.eye(3, 3, dtype=np.float32)
    _, warp_matrix = cv2.findTransformECC(template, target, warp_matrix, cv2.MOTION_HOMOGRAPHY)
    aligned = cv2.warpPerspective(target, warp_matrix, (template.shape[1], template.shape[0]))
    return aligned

def alignment_algorithm_3(template, target):
    akaze = cv2.AKAZE_create()
    kp1, desc1 = akaze.detectAndCompute(template, None)
    kp2, desc2 = akaze.detectAndCompute(target, None)
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(desc1, desc2)
    src_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)
    matrix, _ = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
    aligned = cv2.warpPerspective(target, matrix, (template.shape[1], template.shape[0]))
    return aligned

# === 评估函数 ===
def evaluate_metrics(template, aligned_image):
    ssim_score = ssim(template, aligned_image, full=False)
    _, binary_template = cv2.threshold(template, 128, 255, cv2.THRESH_BINARY)
    _, binary_aligned = cv2.threshold(aligned_image, 128, 255, cv2.THRESH_BINARY)
    intersection = np.logical_and(binary_template, binary_aligned).sum()
    union = np.logical_or(binary_template, binary_aligned).sum()
    iou_score = intersection / union
    diff = cv2.absdiff(template, aligned_image)
    mean_pixel_error = np.mean(diff)
    return ssim_score, iou_score, mean_pixel_error

# === 主测试函数 ===
def batch_evaluation(root_dir, algorithms):
    image_paths = load_image_paths(root_dir)
    results = {f"Algorithm {i+1}": [] for i in range(len(algorithms))}
    pairs = list(itertools.combinations(image_paths, 2))
    
    for template_path, target_path in pairs:
        template = cv2.imread(template_path, cv2.IMREAD_GRAYSCALE)
        target = cv2.imread(target_path, cv2.IMREAD_GRAYSCALE)
        
        for i, algorithm in enumerate(algorithms):
            aligned_image = algorithm(template, target)
            metrics = evaluate_metrics(template, aligned_image)
            results[f"Algorithm {i+1}"].append(metrics)

    summary = {}
    for key, values in results.items():
        metrics = np.array(values)
        avg_metrics = np.mean(metrics, axis=0)
        var_metrics = np.var(metrics, axis=0)
        summary[key] = {
            "Average": avg_metrics,
            "Variance": var_metrics
        }
    
    return summary

# === 可视化函数 ===
def visualize_results(summary):
    algorithms = list(summary.keys())
    metrics = ['SSIM', 'IoU', 'Mean Pixel Error']
    
    avg_values = [summary[algo]["Average"] for algo in algorithms]
    avg_values = np.array(avg_values).T  # 转置以便绘图
    
    plt.figure(figsize=(12, 6))
    for i, metric in enumerate(metrics):
        plt.subplot(1, 3, i+1)
        plt.bar(algorithms, avg_values[i], color=['blue', 'orange', 'green'])
        plt.title(metric)
        plt.ylabel('Score' if i < 2 else 'Error')
        for j, value in enumerate(avg_values[i]):
            plt.text(j, value + 0.01, f"{value:.2f}", ha='center')
    plt.tight_layout()
    plt.show()

# === 运行测试 ===
root_dir = "path/to/images"  # 替换为图片根目录
algorithms = [alignment_algorithm_1, alignment_algorithm_2, alignment_algorithm_3]
summary = batch_evaluation(root_dir, algorithms)
visualize_results(summary)
