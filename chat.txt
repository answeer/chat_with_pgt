from llm_sanitation.agent.profiling import Profiler
from llm_sanitation.agent.planning import Planner
from llm_sanitation.agent.utils.common import get_agents
from llm_sanitation.agent.utils.connectors import (
    get_agent_mfst,
    get_usecase_mfst,
    get_raw_data,
)
from llm_sanitation.logging.logging_setup import LogUtil, LogType, LogLevel
import argparse
from pprint import pprint
import json
from llm_sanitation.logging.logging_setup import LogUtil, LogType, LogLevel

class AgentPipeline:
    """
    A class to represent the execution pipeline for agents, performing profiling and planning based on manifest files.

    Methods
    -------
    run_profiler(agent_manifest_nm, usecase_manifest_nm, agent):
        Validates the agent's skills using the Profiler class.
        
    run_planner(usecase_manifest_nm, agent):
        Generates an execution plan for the given agent using the Planner class.
        
    get_agent_result():
        Retrieves the results of the agent profiling and planning process.

    run_pipeline(agent_manifest_nm, usecase_manifest_nm, payload):
        Coordinates the entire process of agent profiling and planning based on the given manifests and payload.
    """

    def __init__(self):
        """
        Initializes the AgentPipeline object with an empty agent result dictionary.
        """
        self.agent_result = {}

    def run_profiler(self, agent_manifest_nm, usecase_manifest_nm, agent):
        """
        Runs the profiler for a given agent using the provided agent and use case manifest names.

        Parameters
        ----------
        agent_manifest_nm : str
            The name of the agent manifest file.
        usecase_manifest_nm : str
            The name of the use case manifest file.
        agent : str
            The identifier of the agent to be profiled.

        Returns
        -------
        dict
            The result of the profiler's validation, or an empty dictionary if validation fails.
        """
        profiler_obj = Profiler()
        profiler_result = {}
        try:
            profiler_result = profiler_obj.validate_skill(
                agent_manifest_nm, usecase_manifest_nm, agent
            )
        except Exception as e:
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, e)
        return profiler_result

    def run_planner(self, usecase_manifest_nm, agent):
        """
        Runs the planner for a given agent to generate an execution plan.

        Parameters
        ----------
        usecase_manifest_nm : str
            The name of the use case manifest file.
        agent : str
            The identifier of the agent for which the execution plan will be generated.

        Returns
        -------
        dict
            The execution plan generated by the planner, or an empty dictionary if the process fails.
        """
        planner_obj = Planner()
        execution_plan = {}
        try:
            execution_plan = planner_obj.get_exec_plan(usecase_manifest_nm, agent)
        except Exception as e:
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, e)
        return execution_plan

    def get_agent_result(self):
        """
        Retrieves the results of the agent profiling and planning process.

        Returns
        -------
        dict
            A dictionary containing the profiling and planning results for each agent.
        """
        return self.agent_result

    def run_pipeline(self, agent_manifest_nm, usecase_manifest_nm, payload):
        """
        Executes the entire pipeline process for agents, including profiling and planning, 
        based on the provided manifests and payload.

        Parameters
        ----------
        agent_manifest_nm : str
            The name of the agent manifest file.
        usecase_manifest_nm : str
            The name of the use case manifest file.
        payload : dict
            The input payload containing client data, request data, and parameters required for processing.

        Returns
        -------
        list
            A list of execution plans generated by the planner for each agent that passed profiling.
        """
        execution_plans = []
        LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Start to get {}".format(usecase_manifest_nm))
        usecase_mfst = get_usecase_mfst(usecase_manifest_nm)
        LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Start to get the agents")
        agents = get_agents(usecase_mfst)

        for agent in agents:
            self.agent_result[agent] = {}

            # run profiler
            LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Start to run profiler for the agent: {}".format(agent))
            if not self.run_profiler(agent_manifest_nm, usecase_manifest_nm, agent):
                LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Profiling failed for the agent: {}".format(agent))
                continue
            else:
                LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Profiling Successful for the agent: {}".format(agent))

            # run planner
            LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Start to run planner for the agent: {}".format(agent))
            execution_plans.append(self.run_planner(usecase_manifest_nm, agent))
            LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Finish to run planner for the agent: {}".format(agent))

        LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, "Get the execution plans successfully!")
        return execution_plans


if __name__ == "__main__":
    """
    Entry point of the script that runs the agent pipeline with a predefined agent manifest, 
    use case manifest, and payload. The command-line argument parsing is currently commented out for testing purposes.
    """
    # parser = argparse.ArgumentParser(description="Input and Output Sanitation Agent")
    # parser.add_argument(
    #     "-um", "--usecase_manifest_name", help="Usecase Manifest File name", required=True
    # )
    # parser.add_argument(
    #     "-am", "--agent_manifest_name", help="Agent Manifest File name", required=True
    # )
    # parser.add_argument(
    #     "-pl", "--payload", help="Payload", required=True
    # )

    # args = vars(parser.parse_args())
    # Usage
    # agent_manifest_nm = args["agent_manifest_nm"]
    # usecase_manifest_nm = args["usecase_manifest_nm"]
    # payload = args["payload"]

    agent_manifest_nm = "agent_manifest"
    usecase_manifest_nm = "usecase_manifest"
    payload = {
        "clientData": {
            "clientRefNumber": "AP39HN7997",
            "country": "IN",
            "appName": "seige_v3",
        },
        "requestData": {
            "properties": {
                "osname_key": "STORM_GDCE",
                "docClassName": "OTTDoc",
                "filenet_download_params": {
                    "documentids": [
                        {"documentid": "{8032588F-0000-CE33-B3D2-57C34E6FFFF0}"}
                    ]
                },
            }
        },
        "params": {
            "callback_url": "https://swoosh-dev-infox-v1.apps.swoosh-np.ocp.dev.net/api/v1/infox/executeflow",
            "service_name": "identify_pii",
            "safee_id": "SAFEE_SEIGE_03_IN",
            "doc_type": "Invoice",
            "user_name": "1657852",
            "pii_keys": {},
            "args": {"texture_ext_method": "model", "extraction_speed": "fast"},
        },
    }

    agent_pipe_obj = AgentPipeline()
    agent_pipe_obj.run_pipeline(agent_manifest_nm, usecase_manifest_nm, payload)
    print("Agent Pipeline completed")
