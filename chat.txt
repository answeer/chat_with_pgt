from llm_sanitation.scanners.scanner_base import Scanner
import json
import numpy as np
from jsonschema import Draft202012Validator, ValidationError, SchemaError
from jsonschema.exceptions import best_match
from llm_sanitation.logging.logging_setup import LogUtil, LogType, LogLevel

class JsonSchemaValidator(Scanner):
    """
    A Scanner class for validating JSON payloads against a JSON Schema (Draft 2020-12).
    Provides detailed error messages for validation failures.
    """

    def __init__(self, ​**kwargs):
        """
        Initializes the JsonSchemaValidator scanner.

        Args:
            schema (dict): The JSON Schema (Draft 2020-12) definition for validation.
        """
        schema = kwargs["schema"]
        super().__init__("json_schema_validator", 1, schema=schema)
        # 初始化校验器，并启用格式校验（如 "format": "email"）
        self.validator = Draft202012Validator(schema, format_checker=Draft202012Validator.FORMAT_CHECKER)

    def check_json_format(self, payload):
        """
        Validates that a value is parseable as valid JSON.

        Args:
            payload (Any): The data to check for JSON format.

        Returns:
            tuple: A tuple containing the parsed JSON object and any error that occurred during parsing.
        """
        parsed_payload, error = (None, None)
        try:
            if isinstance(payload, str):
                parsed_payload = json.loads(payload)
            else:
                # 如果 payload 不是字符串，直接使用（假设已经是字典或列表）
                parsed_payload = payload
        except json.decoder.JSONDecodeError as e:
            error = f"JSON 解析失败: {str(e)}"
        except TypeError as e:
            error = f"无效的数据类型: {str(e)}"
        return parsed_payload, error

    def format_error_path(self, error_path):
        """
        将错误路径转换为点分隔的字符串（例如 "root.user.address.street"）。

        Args:
            error_path (list): 错误路径的列表（来自 ValidationError.path）。

        Returns:
            str: 点分隔的路径字符串。
        """
        path = []
        for item in error_path:
            if isinstance(item, int):
                path.append(f"[{item}]")  # 数组索引，如 "[0]"
            else:
                path.append(str(item))
        return "root" + "".join(path) if path else "root"

    def validate_with_schema(self, parsed_payload):
        """
        使用 Draft 2020-12 Schema 校验数据，并返回详细错误信息。

        Args:
            parsed_payload (dict/list): 解析后的 JSON 数据。

        Returns:
            tuple: (错误信息列表, 平均得分)
        """
        errors = []
        try:
            # 收集所有错误（而非遇到第一个错误就停止）
            all_errors = list(self.validator.iter_errors(parsed_payload))
            if not all_errors:
                return ["Valid JSON payload."], 1.0

            # 提取最相关的错误（可选）
            primary_error = best_match(all_errors)
            errors.append(self._format_single_error(primary_error))

            # 如果需要所有错误，遍历 all_errors：
            # for error in all_errors:
            #     errors.append(self._format_single_error(error))

        except SchemaError as se:
            errors.append(f"Schema 定义错误: {se.message}")
        except Exception as e:
            LogUtil.log(LogType.ERROR, LogLevel.ERROR, f"校验意外失败: {str(e)}")
            errors.append(f"校验失败: {str(e)}")

        return errors, 0.0  # 得分 0 表示校验失败

    def _format_single_error(self, error):
        """
        格式化单个 ValidationError 的详细信息。

        Args:
            error (ValidationError): 校验错误对象。

        Returns:
            str: 格式化的错误信息。
        """
        error_path = self.format_error_path(error.path)
        error_msg = f"字段 `{error_path}` 校验失败: {error.message}"

        # 根据错误类型添加额外信息
        if error.validator == "required":
            # 必填字段缺失
            missing_field = error.validator_value[0]
            error_msg += f" (缺失字段: `{missing_field}`)"
        elif error.validator == "type":
            # 类型错误
            expected_type = error.validator_value
            actual_type = type(error.instance).__name__
            error_msg += f" (期望类型: `{expected_type}`, 实际类型: `{actual_type}`)"
        elif error.validator == "format":
            # 格式错误（如邮箱、日期）
            error_msg += f" (要求格式: `{error.validator_value}`)"
        elif error.validator == "pattern":
            # 正则表达式不匹配
            error_msg += f" (正则规则: `{error.validator_value}`)"
        elif error.validator == "minItems":
            # 数组长度不足
            error_msg += f" (最小长度: {error.validator_value}, 实际长度: {len(error.instance)})"

        # 显示实际输入的值（避免敏感数据泄露时可注释掉）
        error_msg += f" (实际值: `{error.instance}`)"

        return error_msg

    def predict(self, payload):
        """
        Main prediction method that validates the JSON payload.

        Args:
            payload (Any): The JSON object or string to validate.

        Returns:
            tuple: A tuple containing error messages and a validation score.
        """
        parsed_payload, error = self.check_json_format(payload)
        if error is not None:
            return [error], 0.0
        else:
            return self.validate_with_schema(parsed_payload)

    def format_response(self):
        self.response["prediction"]["json_schema_validator"] = self.pred[0]
        self.response["score"] = self.pred[1]
