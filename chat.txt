def process_exec_plan(self, exec_plan, payload):
    """处理单个执行计划（修复数据隔离问题）"""
    try:
        # 解析执行计划参数（使用局部变量存储）
        task_group = self.determine_task_group(exec_plan)
        execution_plan = exec_plan["exec_plan"][task_group]
        data_paths = exec_plan["data"]
        
        LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, 
                  f"Processing task group: {task_group}")

        # 创建独立的响应对象
        exec_plan_response = {
            "task_group": task_group,
            "data": [],
            "guardrails": []
        }

        # 处理所有数据路径
        for data_path in data_paths:
            # 获取当前执行计划的数据
            data_items = get_data(data_path, payload)
            if not data_items:
                raise GuardrailsError("SWHIOSERR0043", data_path)
            if not isinstance(data_items, list):
                data_items = [data_items]

            # 并行处理当前执行计划的数据项
            with ThreadPoolExecutor(max_workers=4) as executor:
                futures = []
                for data in data_items:
                    # 传递当前执行计划的上下文参数
                    future = executor.submit(
                        self.process_data_item, 
                        data=data,
                        execution_plan=execution_plan,
                        task_group=task_group  # 显式传递任务组
                    )
                    futures.append(future)

                # 收集结果
                for future in as_completed(futures):
                    try:
                        data_item_result = future.result()
                        with self.result_lock:
                            exec_plan_response["data"].append(data_item_result["data"])
                            exec_plan_response["guardrails"].extend(data_item_result["guardrails"])
                    except Exception as e:
                        LogUtil.log(LogType.ERROR, LogLevel.ERROR,
                                  f"Data processing failed: {str(e)}")

        return exec_plan_response

    except Exception as e:
        LogUtil.log(LogType.ERROR, LogLevel.ERROR,
                  f"Failed to process execution plan: {str(e)}")
        raise

def process_data_item(self, data, execution_plan, task_group):
    """处理单个数据项（修复上下文传递问题）"""
    try:
        # 使用显式传递的task_group进行检查
        self.check_task_group(data, task_group)
        
        data_response = {
            "data": data,
            "guardrails": [],
            "task_group": task_group  # 记录数据所属的任务组
        }

        # 强制先执行EncryptionDetector
        if "EncryptionDetector" in execution_plan:
            result = self.run_scanner(
                data=data,
                scanner_nm="EncryptionDetector",
                param=execution_plan["EncryptionDetector"],
                task_group=task_group  # 传递当前上下文
            )
            data_response["guardrails"].append(result)
            if result.get("response", {}).get("is_protected", False):
                LogUtil.log(LogType.TRANSACTION, LogLevel.INFO,
                          f"[{task_group}] Encrypted file detected, skipping other scanners")
                return data_response

        # 并行执行其他扫描器（保持任务组上下文）
        scanners = [s for s in execution_plan.keys() if s != "EncryptionDetector"]
        with ThreadPoolExecutor(max_workers=4) as scanner_executor:
            scanner_futures = {}
            for scanner_nm in scanners:
                future = scanner_executor.submit(
                    self.run_scanner,
                    data=data,
                    scanner_nm=scanner_nm,
                    param=execution_plan[scanner_nm],
                    task_group=task_group  # 传递当前上下文
                )
                scanner_futures[future] = scanner_nm

            # 收集扫描结果
            for future in as_completed(scanner_futures):
                try:
                    result = future.result()
                    data_response["guardrails"].append(result)
                except Exception as e:
                    LogUtil.log(LogType.ERROR, LogLevel.ERROR,
                              f"[{task_group}] Scanner {scanner_futures[future]} failed: {str(e)}")

        return data_response

    except Exception as e:
        LogUtil.log(LogType.ERROR, LogLevel.ERROR,
                  f"[{task_group}] Data item processing failed: {str(e)}")
        raise

def run_scanner(self, data, scanner_nm, param, task_group=None):
    """运行扫描器（增加上下文跟踪）"""
    try:
        # 记录扫描器上下文
        LogUtil.log(LogType.TRANSACTION, LogLevel.DEBUG,
                  f"[{task_group}] Running {scanner_nm} on {data[:20]}...")
        
        # 原有扫描逻辑不变...
        # 添加task_group到日志上下文
        
        return result

    except Exception as e:
        LogUtil.log(LogType.ERROR, LogLevel.ERROR,
                  f"[{task_group}] Scanner {scanner_nm} error: {str(e)}")
        raise
