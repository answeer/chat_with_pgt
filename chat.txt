import argparse
import os
import cv2
import numpy as np
import torch
import yaml
from models import create_model
from PIL import Image

class ImageEnhancer:
    def __init__(self, config_path, model_weights):
        # 加载配置文件
        with open(config_path, 'r') as f:
            self.opt = yaml.safe_load(f)
            
        # 初始化模型
        self.model = create_model(self.opt)
        
        # 特殊处理权重键名（与测试代码一致）
        para = {}
        state_dict = torch.load(model_weights)
        for k, v in state_dict.items():
            para['module.'+k] = v
        self.model.netG.load_state_dict(para, strict=True)
        self.model.eval()
        
        # 获取设备信息
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model.to(self.device)
        
    def preprocess(self, img_path):
        """处理单张输入图像"""
        # 读取图像
        img = Image.open(img_path).convert('RGB')
        
        # 应用测试时的数据预处理（根据实际配置调整）
        if 'datasets' in self.opt and 'val' in self.opt['datasets']:
            # 从配置中获取验证集参数
            dataset_opt = self.opt['datasets']['val']
            img_size = dataset_opt.get('crop_size', 256)
            
            # 实现基本的预处理流程
            img = img.resize((img_size, img_size), Image.BICUBIC)
            img_tensor = torch.from_numpy(np.array(img)).float() / 255.0
            img_tensor = img_tensor.permute(2, 0, 1).unsqueeze(0)  # HWC -> BCHW
        else:
            # 默认预处理
            img_tensor = torch.from_numpy(np.array(img)).float() / 255.0
            img_tensor = img_tensor.permute(2, 0, 1).unsqueeze(0)
        
        return img_tensor.to(self.device)
    
    def enhance(self, img_tensor):
        """执行图像增强"""
        with torch.no_grad():
            # 模拟测试代码的数据处理
            data = {'LQ': img_tensor}
            self.model.feed_data(data)
            self.model.test()
            output = self.model.get_current_visuals()['rlt']
        return output
    
    def postprocess(self, tensor):
        """将输出张量转换为图像"""
        # 将张量转为numpy数组
        tensor = tensor.squeeze().float().cpu().clamp_(0, 1).numpy()
        tensor = tensor.transpose(1, 2, 0)  # CHW -> HWC
        img = (tensor * 255.0).round().astype(np.uint8)
        return img
    
    def save_result(self, img_array, save_path):
        """保存增强结果"""
        cv2.imwrite(save_path, cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR))

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--input', type=str, required=True, help='输入图像路径')
    parser.add_argument('--output', type=str, required=True, help='输出保存路径')
    parser.add_argument('--config', type=str, default='options/train/test_Enhance_MSEC.yml', 
                       help='配置文件路径')
    parser.add_argument('--weights', type=str, required=True, help='模型权重路径')
    
    args = parser.parse_args()
    
    # 初始化增强器
    enhancer = ImageEnhancer(args.config, args.weights)
    
    # 处理图像
    input_tensor = enhancer.preprocess(args.input)
    output_tensor = enhancer.enhance(input_tensor)
    output_img = enhancer.postprocess(output_tensor)
    
    # 保存结果
    os.makedirs(os.path.dirname(args.output), exist_ok=True)
    enhancer.save_result(output_img, args.output)
    print(f'增强结果已保存至 {args.output}')

if __name__ == '__main__':
    main()



import argparse
import os
import cv2
import numpy as np
import torch
import yaml
from models import create_model
from PIL import Image
from tqdm import tqdm

class BatchImageEnhancer:
    def __init__(self, config_path, model_weights):
        # 初始化代码与之前相同...
        
    # 保留之前的预处理、增强、后处理方法...

    def process_folder(self, input_dir, output_dir, extensions=('.jpg', '.png', '.jpeg', '.bmp'), overwrite=False):
        """
        处理整个文件夹的图片
        :param input_dir: 输入文件夹路径
        :param output_dir: 输出根目录
        :param extensions: 支持处理的图片格式
        :param overwrite: 是否覆盖已存在文件
        """
        # 创建进度条
        file_list = []
        for root, _, files in os.walk(input_dir):
            for file in files:
                if file.lower().endswith(extensions):
                    input_path = os.path.join(root, file)
                    # 保持目录结构
                    rel_path = os.path.relpath(root, input_dir)
                    output_subdir = os.path.join(output_dir, rel_path)
                    os.makedirs(output_subdir, exist_ok=True)
                    output_path = os.path.join(output_subdir, file)
                    file_list.append((input_path, output_path))

        print(f"发现 {len(file_list)} 张待处理图片")
        
        # 使用GPU加速批处理
        with torch.no_grad():
            for input_path, output_path in tqdm(file_list, desc="处理进度"):
                try:
                    if not overwrite and os.path.exists(output_path):
                        continue

                    # 预处理
                    input_tensor = self.preprocess(input_path)
                    # 增强
                    output_tensor = self.enhance(input_tensor)
                    # 后处理
                    output_img = self.postprocess(output_tensor)
                    # 保存
                    self.save_result(output_img, output_path)
                    
                except Exception as e:
                    print(f"\n处理文件 {input_path} 时出错: {str(e)}")
                    continue

def main():
    parser = argparse.ArgumentParser(description='批量图像增强工具')
    parser.add_argument('--input', type=str, required=True, 
                       help='输入路径（文件或文件夹）')
    parser.add_argument('--output', type=str, required=True,
                       help='输出目录路径')
    parser.add_argument('--config', type=str, default='options/train/test_Enhance_MSEC.yml',
                       help='配置文件路径')
    parser.add_argument('--weights', type=str, required=True,
                       help='模型权重路径')
    parser.add_argument('--ext', nargs='+', default=['.jpg', '.png'], 
                       help='支持的文件扩展名列表，例如 .jpg .png')
    parser.add_argument('--overwrite', action='store_true',
                       help='覆盖已存在的输出文件')
    
    args = parser.parse_args()
    
    enhancer = BatchImageEnhancer(args.config, args.weights)

    # 自动判断输入类型
    if os.path.isfile(args.input):
        # 单文件处理模式
        output_path = args.output if args.output.endswith(tuple(args.ext)) \
            else os.path.join(args.output, os.path.basename(args.input))
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        
        input_tensor = enhancer.preprocess(args.input)
        output_tensor = enhancer.enhance(input_tensor)
        output_img = enhancer.postprocess(output_tensor)
        enhancer.save_result(output_img, output_path)
        print(f"已保存结果到 {output_path}")
        
    elif os.path.isdir(args.input):
        # 文件夹批处理模式
        enhancer.process_folder(
            input_dir=args.input,
            output_dir=args.output,
            extensions=tuple(args.ext),
            overwrite=args.overwrite
        )
        print(f"处理完成！结果保存在 {args.output}")
    else:
        raise ValueError("无效的输入路径")

if __name__ == '__main__':
    main()
