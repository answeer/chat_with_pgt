from threading import Lock

class Action:
    def __init__(
        self,
        ​**kwargs,
    ):
        # ...其他初始化代码...
        self.lock = Lock()  # 新增线程锁

    def run_scanner(self, data, scanner_nm, param, ​**kwargs):
        # ...原有扫描器调用代码...

        # 使用锁保护共享资源
        with self.lock:
            self.nstp_result.append(result.get("NSTP"))
            if result.get("NSTP"):
                self.failed_response.append(str(result.get("response", "")))

        return result

    def process_scanners(self, data, execution_plan):
        exec_plan = copy.deepcopy(execution_plan)
        results = []
        
        # 优先处理加密检测（顺序执行）
        if "EncryptionDetector" in exec_plan:
            result = self.run_scanner(data, "EncryptionDetector", exec_plan['EncryptionDetector'], ​**self.kwargs)
            results.append(result)
            del exec_plan["EncryptionDetector"]
            if result["NSTP"]:
                LogUtil.log(LogType.TRANSACTION, LogLevel.INFO, 
                           f"File is encrypted, skipping scanners: {list(exec_plan.keys())}")
                return results
        
        # 并行执行剩余扫描器
        if exec_plan:
            with ThreadPoolExecutor() as executor:
                futures = []
                for scanner_nm, param in exec_plan.items():
                    future = executor.submit(
                        self.run_scanner,  # 提交扫描任务
                        data,
                        scanner_nm,
                        param,
                        ​**self.kwargs
                    )
                    futures.append(future)
                
                # 收集并处理结果
                for future in as_completed(futures):
                    try:
                        result = future.result()
                        results.append(result)
                    except Exception as e:
                        LogUtil.log(LogType.ERROR, LogLevel.ERROR,
                                   f"Scanner execution failed: {str(e)}")
        
        return results
