import cv2
import pandas as pd
import re
import numpy as np

def calculate_confidence(w, h, min_area=100):
    # 计算宽高比
    aspect_ratio = w / float(h)
    area = w * h

    # 确保面积足够大，避免太小的区域
    if area < min_area:
        return 0  # 如果面积太小，置信度为0

    # 根据宽高比和面积计算置信度
    # 理想宽高比应该在0.2到1之间，面积越大，置信度越高
    if 0.2 < aspect_ratio < 1.0:
        confidence = area  # 使用面积作为置信度的主要衡量标准
        return confidence

    return 0  # 如果宽高比不合理，置信度为0

def split_large_contour(card_number_region, contour, x_min, y_min, max_digit_width):
    # 对包含多个数字的轮廓进行水平投影分割
    x, y, w, h = cv2.boundingRect(contour)
    
    # 如果轮廓宽度大于典型的单个数字宽度的阈值，尝试分割
    if w > max_digit_width:
        region = card_number_region[y:y+h, x:x+w]
        
        # 水平投影分析，计算每列的黑色像素数
        horizontal_projection = np.sum(region, axis=0)
        
        # 寻找黑色像素较少的地方（即可能是字符间的空隙）
        split_points = []
        for i in range(1, len(horizontal_projection) - 1):
            if horizontal_projection[i] == 0 and horizontal_projection[i - 1] > 0 and horizontal_projection[i + 1] > 0:
                split_points.append(i)
        
        # 如果找到分割点，按照分割点将轮廓分成多个子区域
        sub_contours = []
        prev_x = 0
        for split_point in split_points:
            sub_contours.append((x + prev_x, y, split_point - prev_x, h))
            prev_x = split_point
        
        # 添加最后一个分割区域
        if prev_x < w:
            sub_contours.append((x + prev_x, y, w - prev_x, h))
        
        return sub_contours

    return [(x, y, w, h)]  # 如果宽度不大，则不进行分割

# 1. 读取 Excel 文件
excel_file = 'id_card_data.xlsx'  # 替换为你的 Excel 文件路径
df = pd.read_excel(excel_file)

# 2. 读取图像
image = cv2.imread('id_card_image.jpg')  # 替换为你的 ID 卡图像路径

# 定义单个数字的最大宽度
max_digit_width = 50  # 根据实际情况调整此值

# 遍历 Excel 中的每一行，并只处理包含12位数字的行
for index, row in df.iterrows():
    id_card_number = str(row['text'])  # 假设 'text' 列存储的是卡号文本

    # 只处理12位数字的行
    if re.match(r'^\d{12}$', id_card_number):
        x_min, y_min, x_max, y_max = row['x_min'], row['y_min'], row['x_max'], row['y_max']

        # 3. 提取卡号的 bounding box 区域
        card_number_region = image[y_min:y_max, x_min:x_max]

        # 4. 转换为灰度图像并二值化处理
        gray = cv2.cvtColor(card_number_region, cv2.COLOR_BGR2GRAY)
        _, thresh = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY_INV)

        # 5. 进行轮廓检测，找到每个数字
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # 6. 对轮廓计算置信度并过滤掉小轮廓
        candidates = []
        for contour in contours:
            x, y, w, h = cv2.boundingRect(contour)
            
            # 计算置信度并过滤掉太小的轮廓
            confidence = calculate_confidence(w, h, min_area=100)  # 设置最小面积
            if confidence > 0:  # 只保留有置信度的轮廓
                # 如果轮廓包含多个数字，进行分割
                sub_contours = split_large_contour(card_number_region, contour, x_min, y_min, max_digit_width)
                for sub_x, sub_y, sub_w, sub_h in sub_contours:
                    candidates.append((sub_x, sub_y, sub_w, sub_h, confidence))

        # 7. 根据置信度排序并假设前12个轮廓是数字
        candidates = sorted(candidates, key=lambda c: (c[0], -c[4]))  # 按 x 坐标排序，置信度作为次要排序

        # 只取前12个区域
        if len(candidates) >= 12:
            candidates = candidates[:12]

            # 根据 x 坐标排序后，提取前8个数字的 bounding box
            front_8_digits = candidates[:8]

            # 8. 绘制前8位数字的 bounding box 到原始图像上
            for candidate in front_8_digits:
                x, y, w, h, _ = candidate
                cv2.rectangle(image, (x_min + x, y_min + y), (x_min + x + w, y_min + y + h), (0, 255, 0), 2)

# 9. 显示结果图像
cv2.imshow('ID Card with Front 8 Digits Bounding Box', image)
cv2.waitKey(0)
cv2.destroyAllWindows()
