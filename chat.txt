import io
import numpy as np
import cv2
from PIL import Image
from flask import Flask, request, jsonify
from paddleocr import PaddleOCR

app = Flask(__name__)

# 初始化 OCR 模型
ocr = PaddleOCR(use_angle_cls=True, lang='ch', det_db_score_mode='fast')  # 可以调整为适合需求的模型

def ocr_image(pil_img):
    """
    处理图片并返回 OCR 识别结果：文本行及其坐标
    """
    img = cv2.cvtColor(np.array(pil_img), cv2.COLOR_RGB2BGR)
    result = ocr.ocr(img, cls=True)
    lines = []
    for idx in range(len(result)):
        res = result[idx]
        for line in res:
            poly, (txt, conf) = line
            lines.append({
                "text": txt,
                "confidence": float(conf),
                "polygon": [[float(p[0]), float(p[1])] for p in poly]
            })
    return lines

@app.route("/ocr", methods=["POST"])
def ocr_endpoint():
    try:
        # 检查是否有图片文件上传
        if "image" not in request.files:
            return jsonify({"error": "missing file field 'image'"}), 400
        f = request.files["image"]
        raw = f.read()
        pil = Image.open(io.BytesIO(raw)).convert("RGB")
        width, height = pil.size

        # OCR 识别
        lines = ocr_image(pil)

        # 将 OCR 坐标归一化到 0-1 范围内（相对坐标）
        for l in lines:
            l["polygon_norm"] = [[x/width, y/height] for (x,y) in l["polygon"]]

        return jsonify({
            "width": width, "height": height,
            "lines": lines
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    # 启动 Flask 服务
    app.run(host="0.0.0.0", port=8001)



def process_ocr_results(self, lines, image_width, image_height):
        """
        处理 OCR 识别结果，进行行聚合、块分组、文本匹配等后处理
        """
        blocks = self.lines_to_blocks_dbscan(lines)
        entity_positions = self.map_entities_to_positions(blocks)
        
        # 将坐标从相对值转换为原图坐标
        for block in blocks:
            block["display_box"] = self.convert_to_absolute_coordinates(block["display_box"], image_width, image_height)
            for line in block["lines"]:
                line["polygon"] = self.convert_to_absolute_coordinates(line["polygon"], image_width, image_height)
        
        return blocks, entity_positions

    def lines_to_blocks_dbscan(self, lines, eps_scale=1.3, min_samples=1):
        """
        使用 DBSCAN 聚类进行行的块分组
        """
        mh = self.median_line_height(lines)
        feats = []
        for l in lines:
            poly = np.array(l["polygon"], dtype=np.float32)
            x_left = float(np.min(poly[:,0]))
            y_center = float(np.mean(poly[:,1]))
            feats.append([x_left / mh, y_center / mh])
        X = np.array(feats, dtype=np.float32)

        db = DBSCAN(eps=eps_scale, min_samples=min_samples, metric='euclidean')
        labels = db.fit_predict(X)

        clusters = {}
        for lbl, l in zip(labels, lines):
            clusters.setdefault(lbl, []).append(l)

        blocks = []
        bid = 0
        for lbl, group in clusters.items():
            group_sorted = sorted(group, key=lambda l: np.min(np.array(l["polygon"])[:,0]))
            text = " ".join([l["text"] for l in group_sorted])
            all_pts = np.concatenate([np.array(l["polygon"]) for l in group_sorted], axis=0)
            x1, y1 = float(np.min(all_pts[:,0])), float(np.min(all_pts[:,1]))
            x2, y2 = float(np.max(all_pts[:,0])), float(np.max(all_pts[:,1]))

            blocks.append({
                "block_id": bid,
                "text": text,
                "norm_text": text.lower(),
                "lines": group_sorted,
                "display_box": [x1, y1, x2, y2],
            })
            bid += 1

        blocks.sort(key=lambda b: b["display_box"][1])
        return blocks

    def map_entities_to_positions(self, blocks):
        """
        根据识别的文本，映射对应的实体位置（例如提取地址、姓名等）
        """
        # 这里做一些基本的实体匹配逻辑，实际可根据需求扩展
        entity_positions = {}
        for block in blocks:
            for entity in ["address", "name"]:  # 假设提取地址和姓名
                if entity in block["text"].lower():
                    entity_positions[entity] = block["display_box"]
        return entity_positions

    def convert_to_absolute_coordinates(self, coords, image_width, image_height):
        """
        将归一化的坐标转换为绝对坐标
        """
        return [
            [coord[0] * image_width, coord[1] * image_height] for coord in coords
        ]

    def median_line_height(self, lines):
        """
        计算行高的中位数
        """
        heights = []
        for l in lines:
            poly = np.array(l["polygon"], dtype=np.float32)
            y_vals = poly[:,1]
            heights.append(np.max(y_vals) - np.min(y_vals))
        return np.median(heights)


from flask import Flask, request, jsonify
from document_processor import DocumentProcessor

app = Flask(__name__)

# 初始化 DocumentProcessor
processor = DocumentProcessor()

@app.route("/ocr", methods=["POST"])
def ocr_endpoint():
    try:
        if "image" not in request.files:
            return jsonify({"error": "missing file field 'image'"}), 400
        f = request.files["image"]
        raw = f.read()
        pil = Image.open(io.BytesIO(raw)).convert("RGB")
        width, height = pil.size

        # OCR 识别
        lines = ocr_image(pil)

        # 将 OCR 坐标归一化到 0-1 范围内（相对坐标）
        for l in lines:
            l["polygon_norm"] = [[x/width, y/height] for (x,y) in l["polygon"]]

        # 后处理：块分组、实体位置映射等
        blocks, entity_positions = processor.process_ocr_results(lines, width, height)

        return jsonify({
            "width": width, "height": height,
            "blocks": blocks,
            "entity_positions": entity_positions
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8001)
