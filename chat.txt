import argparse
import os
import cv2
import numpy as np
import torch
import yaml
from models import create_model
from PIL import Image

class ImageEnhancer:
    def __init__(self, config_path, model_weights):
        # 加载配置文件
        with open(config_path, 'r') as f:
            self.opt = yaml.safe_load(f)
            
        # 初始化模型
        self.model = create_model(self.opt)
        
        # 特殊处理权重键名（与测试代码一致）
        para = {}
        state_dict = torch.load(model_weights)
        for k, v in state_dict.items():
            para['module.'+k] = v
        self.model.netG.load_state_dict(para, strict=True)
        self.model.eval()
        
        # 获取设备信息
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model.to(self.device)
        
    def preprocess(self, img_path):
        """处理单张输入图像"""
        # 读取图像
        img = Image.open(img_path).convert('RGB')
        
        # 应用测试时的数据预处理（根据实际配置调整）
        if 'datasets' in self.opt and 'val' in self.opt['datasets']:
            # 从配置中获取验证集参数
            dataset_opt = self.opt['datasets']['val']
            img_size = dataset_opt.get('crop_size', 256)
            
            # 实现基本的预处理流程
            img = img.resize((img_size, img_size), Image.BICUBIC)
            img_tensor = torch.from_numpy(np.array(img)).float() / 255.0
            img_tensor = img_tensor.permute(2, 0, 1).unsqueeze(0)  # HWC -> BCHW
        else:
            # 默认预处理
            img_tensor = torch.from_numpy(np.array(img)).float() / 255.0
            img_tensor = img_tensor.permute(2, 0, 1).unsqueeze(0)
        
        return img_tensor.to(self.device)
    
    def enhance(self, img_tensor):
        """执行图像增强"""
        with torch.no_grad():
            # 模拟测试代码的数据处理
            data = {'LQ': img_tensor}
            self.model.feed_data(data)
            self.model.test()
            output = self.model.get_current_visuals()['rlt']
        return output
    
    def postprocess(self, tensor):
        """将输出张量转换为图像"""
        # 将张量转为numpy数组
        tensor = tensor.squeeze().float().cpu().clamp_(0, 1).numpy()
        tensor = tensor.transpose(1, 2, 0)  # CHW -> HWC
        img = (tensor * 255.0).round().astype(np.uint8)
        return img
    
    def save_result(self, img_array, save_path):
        """保存增强结果"""
        cv2.imwrite(save_path, cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR))

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--input', type=str, required=True, help='输入图像路径')
    parser.add_argument('--output', type=str, required=True, help='输出保存路径')
    parser.add_argument('--config', type=str, default='options/train/test_Enhance_MSEC.yml', 
                       help='配置文件路径')
    parser.add_argument('--weights', type=str, required=True, help='模型权重路径')
    
    args = parser.parse_args()
    
    # 初始化增强器
    enhancer = ImageEnhancer(args.config, args.weights)
    
    # 处理图像
    input_tensor = enhancer.preprocess(args.input)
    output_tensor = enhancer.enhance(input_tensor)
    output_img = enhancer.postprocess(output_tensor)
    
    # 保存结果
    os.makedirs(os.path.dirname(args.output), exist_ok=True)
    enhancer.save_result(output_img, args.output)
    print(f'增强结果已保存至 {args.output}')

if __name__ == '__main__':
    main()
